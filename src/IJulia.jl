__precompile__()
module IJulia
using Compat
import Compat.String

# in the Jupyter front-end, enable verbose output via IJulia.set_verbose()
verbose = false
function set_verbose(v::Bool=true)
    global verbose = v
end

# set this to false for debugging, to disable stderr redirection
const capture_stderr = true

using ZMQ
using JSON

using Nettle
const hmacstate = HMACState[]
function hmac(s1,s2,s3,s4)
    if isempty(hmacstate)
        return ""
    else
        update!(hmacstate[1], s1)
        update!(hmacstate[1], s2)
        update!(hmacstate[1], s3)
        update!(hmacstate[1], s4)
        return hexdigest!(hmacstate[1])
    end
end

const depfile = joinpath(dirname(@__FILE__), "..", "deps", "deps.jl")
isfile(depfile) || error("IJulia not properly installed. Please run Pkg.build(\"IJulia\")")
include(depfile) # generated by Pkg.build("IJulia")

# use our own random seed for msg_id so that we
# don't alter the user-visible random state (issue #336)
const IJulia_RNG = MersenneTwister()
uuid4() = repr(Base.Random.uuid4(IJulia_RNG))

const orig_STDIN  = Ref{IO}()
const orig_STDOUT = Ref{IO}()
const orig_STDERR = Ref{IO}()
function __init__()
    srand(IJulia_RNG)
    orig_STDIN[]  = STDIN
    orig_STDOUT[] = STDOUT
    orig_STDERR[] = STDERR
end

inited = false
const threadid = Array(Int, 128) # sizeof(uv_thread_t) <= 8 on Linux, OSX, Win

# the following constants need to be initialized in init().
const ctx = Ref{Context}()
const publish = Ref{Socket}()
const raw_input = Ref{Socket}()
const requests = Ref{Socket}()
const control = Ref{Socket}()
const heartbeat = Ref{Socket}()
const profile = Dict{String,Any}()
const read_stdout = Ref{Base.PipeEndpoint}()
const read_stderr = Ref{Base.PipeEndpoint}()
const socket_locks = Dict{Socket,ReentrantLock}()

function init(args)
    inited && error("IJulia is already running")
    if length(args) > 0
        merge!(profile, open(JSON.parse,args[1]))
        verbose && println("PROFILE = $profile")
    else
        # generate profile and save
        let port0 = 5678
            merge!(profile, Dict{String,Any}(
                "ip" => "127.0.0.1",
                "transport" => "tcp",
                "stdin_port" => port0,
                "control_port" => port0+1,
                "hb_port" => port0+2,
                "shell_port" => port0+3,
                "iopub_port" => port0+4,
                "key" => uuid4()
            ))
            fname = "profile-$(getpid()).json"
            println("connect ipython with --existing $(pwd())/$fname")
            open(fname, "w") do f
                JSON.print(f, profile)
            end
        end
    end

    if !isempty(profile["key"])
        signature_scheme = get(profile, "signature_scheme", "hmac-sha256")
        isempty(signature_scheme) && (signature_scheme = "hmac-sha256")
        signature_scheme = split(signature_scheme, "-")
        if signature_scheme[1] != "hmac" || length(signature_scheme) != 2
            error("unrecognized signature_scheme $signature_scheme")
        end
        push!(hmacstate, HMACState(signature_scheme[2], profile["key"]))
    end

    ctx[] = Context()
    publish[] = Socket(ctx[], PUB)
    raw_input[] = Socket(ctx[], ROUTER)
    requests[] = Socket(ctx[], ROUTER)
    control[] = Socket(ctx[], ROUTER)
    heartbeat[] = Socket(ctx[], ROUTER)
    bind(publish[], "$(profile["transport"])://$(profile["ip"]):$(profile["iopub_port"])")
    bind(requests[], "$(profile["transport"])://$(profile["ip"]):$(profile["shell_port"])")
    bind(control[], "$(profile["transport"])://$(profile["ip"]):$(profile["control_port"])")
    bind(raw_input[], "$(profile["transport"])://$(profile["ip"]):$(profile["stdin_port"])")
    bind(heartbeat[], "$(profile["transport"])://$(profile["ip"]):$(profile["hb_port"])")

    # associate a lock with each socket so that multi-part messages
    # on a given socket don't get inter-mingled between tasks.
    for s in (publish[], raw_input[], requests[], control[], heartbeat[])
        socket_locks[s] = ReentrantLock()
    end

    start_heartbeat(heartbeat[])
    read_stdout[], = redirect_stdout()
    if capture_stderr
        read_stderr[], = redirect_stderr()
    end

    send_status("starting")
    global inited = true
end

include("stdio.jl")
include("msg.jl")
include("history.jl")
include("handlers.jl")
include("heartbeat.jl")

function eventloop(socket)
    task_local_storage(:IJulia_task, "write task")
    try
        while true
            msg = recv_ipython(socket)
            try
                send_status("busy", msg.header)
                handlers[msg.header["msg_type"]](socket, msg)
            catch e
                # Try to keep going if we get an exception, but
                # send the exception traceback to the front-ends.
                # (Ignore SIGINT since this may just be a user-requested
                #  kernel interruption to interrupt long calculations.)
                if !isa(e, InterruptException)
                    content = error_content(e, msg="KERNEL EXCEPTION")
                    map(s -> println(orig_STDERR[], s), content["traceback"])
                    send_ipython(publish[],
                                 execute_msg == nothing ?
                                 Msg([ "error" ],
                                     Dict("msg_id" => uuid4(),
                                          "username" => "jlkernel",
                                          "session" => uuid4(),
                                          "msg_type" => "error",
                                          "version" => "5.0"),
                                     content) :
                                 msg_pub(execute_msg, "error", content))
                end
            finally
                send_status("idle", msg.header)
            end
        end
    catch e
        # the Jupyter manager may send us a SIGINT if the user
        # chooses to interrupt the kernel; don't crash on this
        if isa(e, InterruptException)
            eventloop(socket)
        else
            rethrow()
        end
    end
end

function waitloop()
    @async eventloop(control[])
    requests_task = @async eventloop(requests[])
    while true
        try
            wait()
        catch e
            # send interrupts (user SIGINT) to the code-execution task
            if isa(e, InterruptException)
                @async Base.throwto(requests_task, e)
            else
                rethrow()
            end
        end
    end
end

export notebook
function notebook(; dir=homedir(), detached=false)
    inited && error("IJulia is already running")
    p = spawn(Cmd(`$notebook_cmd`, detach=true, dir=dir))
    if !detached
        try
            wait(p)
        catch e
            if isa(e, InterruptException)
                kill(p, 2) # SIGINT
            else
                kill(p) # SIGTERM
                rethrow()
            end
        end
    end
    return p
end

end # IJulia
