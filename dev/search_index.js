var documenterSearchIndex = {"docs":
[{"location":"manual/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"manual/installation/#Installing-IJulia","page":"Installation","title":"Installing IJulia","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"First, install Julia from Download Julia page. Then run the Julia application (double-click on it); a window with a julia> prompt will appear. After ensuring that you have activated the default Julia environment, at the prompt, type:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"IJulia\")","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"to install IJulia.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"This process installs a kernel specification that tells Jupyter (or JupyterLab) etcetera how to launch Julia.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Pkg.add(\"IJulia\") does not actually install Jupyter itself. You can install Jupyter if you want, but it can also be installed automatically when you run IJulia.notebook() below.  (You can force it to use a specific jupyter installation by setting ENV[\"JUPYTER\"] to the path of the jupyter program before Pkg.add, or before running Pkg.build(\"IJulia\"); your preference is remembered on subsequent updates.","category":"page"},{"location":"manual/installation/#Updating-Julia-and-IJulia","page":"Installation","title":"Updating Julia and IJulia","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Julia is improving rapidly, so it won't be long before you want to update to a more recent version.  To update the packages only, keeping Julia itself the same, just run:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Pkg.update()","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"at the Julia prompt (or in IJulia).","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"If you download and install a new version of Julia from the Julia web site, you will also probably want to update the packages with Pkg.update() (in case newer versions of the packages are required for the most recent Julia).  In any case, if you install a new Julia binary (or do anything that changes the location of Julia on your computer), you must update the IJulia installation (to tell Jupyter where to find the new Julia) by running","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Pkg.build(\"IJulia\")","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"at the Julia command line (important: not in IJulia).","category":"page"},{"location":"manual/installation/#Installing-additional-Julia-kernels","page":"Installation","title":"Installing additional Julia kernels","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"You can also install additional Julia kernels, for example, to pass alternative command-line arguments to the julia executable, by using the IJulia.installkernel function.  See the help for this function (? IJulia.installkernel in Julia) for complete details.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"For example, if you want to run Julia with all deprecation warnings disabled, you can do:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"using IJulia\ninstallkernel(\"Julia nodeps\", \"--depwarn=no\")","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"and a kernel called Julia nodeps 0.7 (if you are using Julia 0.7) will be installed (will show up in your main Jupyter kernel menu) that lets you open notebooks with this flag. Note that the default kernel that IJulia installs passes the --project=@. option to Julia, if you want to preserve this behaviour for custom kernels make sure to pass it explicitly to IJulia.installkernel:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"installkernel(\"Julia nodeps\", \"--depwarn=no\", \"--project=@.\")","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"You can also install kernels to run Julia with different environment variables, for example to set JULIA_NUM_THREADS for use with Julia multithreading:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"using IJulia\ninstallkernel(\"Julia (4 threads)\", env=Dict(\"JULIA_NUM_THREADS\"=>\"4\"))","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"The env keyword should be a Dict mapping environment variables to values.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"To prevent IJulia from installing a default kernel when the package is built, define the IJULIA_NODEFAULTKERNEL environment variable before adding/building IJulia.","category":"page"},{"location":"manual/installation/#Low-level-Information","page":"Installation","title":"Low-level Information","text":"","category":"section"},{"location":"manual/installation/#Using-older-IPython-versions","page":"Installation","title":"Using older IPython versions","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"While we strongly recommend using IPython version 3 or later (note that this has nothing to do with whether you use Python version 2 or 3), we recognize that in the short term some users may need to continue using IPython 2.x.  You can do this by checkout out the ipython2 branch of the IJulia package:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Pkg.checkout(\"IJulia\", \"ipython2\")\nPkg.build(\"IJulia\")","category":"page"},{"location":"manual/installation/#Manual-installation-of-IPython","page":"Installation","title":"Manual installation of IPython","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"First, you will need to install a few prerequisites:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"You need version 3.0 or later of IPython, or version 4 or later of Jupyter.  Note that IPython 3.0 was released in February 2015, so if you have an older operating system you may have to install IPython manually. On Mac and Windows systems, it is currently easiest to use the Anaconda Python installer.\nTo use the IPython notebook interface, which runs in your web browser and provides a rich multimedia environment, you will need to install the jsonschema, Jinja2, Tornado, and pyzmq (requires apt-get install libzmq-dev and possibly pip install --upgrade --force-reinstall pyzmq on Ubuntu if you are using pip) Python packages. (Given the pip installer, pip install jsonschema jinja2 tornado pyzmq should normally be sufficient.)  These should have been automatically installed if you installed IPython itself via easy_install or pip.\nTo use the IPython qtconsole interface, you will need to install PyQt4 or PySide.\nYou need Julia version 0.7 or later.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Once IPython 3.0+ and Julia 0.7+ are installed, you can install IJulia from a Julia console by typing:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Pkg.add(\"IJulia\")","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"This will download IJulia and a few other prerequisites, and will set up a Julia kernel for IPython.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"If the command above returns an error, you may need to run Pkg.update(), then retry it, or possibly run Pkg.build(\"IJulia\") to force a rebuild.","category":"page"},{"location":"_changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"This documents notable changes in IJulia.jl. The format is based on Keep a Changelog.","category":"page"},{"location":"_changelog/#Unreleased","page":"Changelog","title":"Unreleased","text":"","category":"section"},{"location":"_changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"notebook() and jupyterlab() now support a verbose keyword argument to echo output from Jupyter to the terminal, which can be useful when debugging kernels ([#1157]).","category":"page"},{"location":"_changelog/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"The Julia major and minor version are no longer appended to a custom specname in installkernel(). The default specname that derives from name and appends the Julia version remains unchanged ([#1154]).","category":"page"},{"location":"_changelog/#[v1.27.0]","page":"Changelog","title":"[v1.27.0]","text":"","category":"section"},{"location":"_changelog/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"installkernel() now supports a displayname argument to customize the kernel display name ([#1137]).","category":"page"},{"location":"_changelog/#Fixed-2","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"The internal heartbeat thread will now shut down cleanly ([#1135], [#1144], [#1150]). This should prevent segfaults upon exit.\nVarious fixes to the messaging code to be compliant with Jupyter ([#1138], [#1150]).\nImproved threadsafety of the IO-handling code so that it should be safe to call flush() concurrently ([#1149]).","category":"page"},{"location":"changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"This documents notable changes in IJulia.jl. The format is based on Keep a Changelog.","category":"page"},{"location":"changelog/#Unreleased","page":"Changelog","title":"Unreleased","text":"","category":"section"},{"location":"changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"notebook() and jupyterlab() now support a verbose keyword argument to echo output from Jupyter to the terminal, which can be useful when debugging kernels (#1157).","category":"page"},{"location":"changelog/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The Julia major and minor version are no longer appended to a custom specname in installkernel(). The default specname that derives from name and appends the Julia version remains unchanged (#1154).","category":"page"},{"location":"changelog/#[v1.27.0](https://github.com/JuliaLang/IJulia.jl/releases/tag/v1.27.0)","page":"Changelog","title":"v1.27.0","text":"","category":"section"},{"location":"changelog/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"installkernel() now supports a displayname argument to customize the kernel display name (#1137).","category":"page"},{"location":"changelog/#Fixed-2","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The internal heartbeat thread will now shut down cleanly (#1135, #1144, #1150). This should prevent segfaults upon exit.\nVarious fixes to the messaging code to be compliant with Jupyter (#1138, #1150).\nImproved threadsafety of the IO-handling code so that it should be safe to call flush() concurrently (#1149).","category":"page"},{"location":"library/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"library/internals/#Initialization","page":"Internals","title":"Initialization","text":"","category":"section"},{"location":"library/internals/#IJulia.init","page":"Internals","title":"IJulia.init","text":"init(args)\n\nInitialize a kernel. args may either be empty or have one element containing the path to an existing connection file. If args is empty a connection file will be generated.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Cell-execution-hooks","page":"Internals","title":"Cell execution hooks","text":"","category":"section"},{"location":"library/internals/#IJulia.pop_posterror_hook","page":"Internals","title":"IJulia.pop_posterror_hook","text":"pop_posterror_hook(f::Function)\n\nRemove a function f() from the list of functions to execute after an error occurs when a notebook cell is evaluated.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.pop_postexecute_hook","page":"Internals","title":"IJulia.pop_postexecute_hook","text":"pop_postexecute_hook(f::Function)\n\nRemove a function f() from the list of functions to execute after executing any notebook cell.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.pop_preexecute_hook","page":"Internals","title":"IJulia.pop_preexecute_hook","text":"pop_preexecute_hook(f::Function)\n\nRemove a function f() from the list of functions to execute before executing any notebook cell.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.push_posterror_hook","page":"Internals","title":"IJulia.push_posterror_hook","text":"pop_posterror_hook(f::Function)\n\nRemove a function f() from the list of functions to execute after an error occurs when a notebook cell is evaluated.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.push_postexecute_hook","page":"Internals","title":"IJulia.push_postexecute_hook","text":"push_postexecute_hook(f::Function)\n\nPush a function f() onto the end of a list of functions to execute after executing any notebook cell.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.push_preexecute_hook","page":"Internals","title":"IJulia.push_preexecute_hook","text":"push_preexecute_hook(f::Function)\n\nPush a function f() onto the end of a list of functions to execute before executing any notebook cell.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Messaging","page":"Internals","title":"Messaging","text":"","category":"section"},{"location":"library/internals/#IJulia.Msg","page":"Internals","title":"IJulia.Msg","text":"IPython message struct.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#IJulia.msg_header","page":"Internals","title":"IJulia.msg_header","text":"msg_header(m::Msg, msg_type::String)\n\nCreate a header for a Msg.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.send_ipython","page":"Internals","title":"IJulia.send_ipython","text":"send_ipython(socket, m::Msg)\n\nSend a message m. This will lock socket.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.recv_ipython","page":"Internals","title":"IJulia.recv_ipython","text":"recv_ipython(socket)\n\nWait for and get a message. This will lock socket.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.set_cur_msg","page":"Internals","title":"IJulia.set_cur_msg","text":"Jupyter associates cells with message headers. Once a cell's execution state has been set as to idle, it will silently drop stream messages (i.e. output to stdout and stderr) - see https://github.com/jupyter/notebook/issues/518. When using Interact, and a widget's state changes, a new message header is sent to the IJulia kernel, and while Reactive is updating Signal graph state, it's execution state is busy, meaning Jupyter will not drop stream messages if Interact can set the header message under which the stream messages will be sent. Hence the need for this function.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.send_status","page":"Internals","title":"IJulia.send_status","text":"send_status(state::AbstractString, parent_msg::Msg=execute_msg)\n\nPublish a status message.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Request-handlers","page":"Internals","title":"Request handlers","text":"","category":"section"},{"location":"library/internals/#IJulia.connect_request","page":"Internals","title":"IJulia.connect_request","text":"connect_request(socket, msg)\n\nHandle a connect request.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.execute_request","page":"Internals","title":"IJulia.execute_request","text":"execute_request(socket, msg)\n\nHandle a execute request. This will execute Julia code, along with Pkg and shell commands.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.shutdown_request","page":"Internals","title":"IJulia.shutdown_request","text":"shutdown_request(socket, msg)\n\nHandle a shutdown request. After sending the reply this will exit the process.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.interrupt_request","page":"Internals","title":"IJulia.interrupt_request","text":"interrupt_request(socket, msg)\n\nHandle a interrupt request. This will throw an InterruptException to the currently executing request handler.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.inspect_request","page":"Internals","title":"IJulia.inspect_request","text":"inspect_request(socket, msg)\n\nHandle a introspection request.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.history_request","page":"Internals","title":"IJulia.history_request","text":"history_request(socket, msg)\n\nHandle a history request. This is currently only a dummy implementation that doesn't actually do anything.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.complete_request","page":"Internals","title":"IJulia.complete_request","text":"complete_request(socket, msg)\n\nHandle a completion request.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.kernel_info_request","page":"Internals","title":"IJulia.kernel_info_request","text":"kernel_info_request(socket, msg)\n\nHandle a kernel info request.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.is_complete_request","page":"Internals","title":"IJulia.is_complete_request","text":"is_complete_request(socket, msg)\n\nHandle a completeness request.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Event-loop","page":"Internals","title":"Event loop","text":"","category":"section"},{"location":"library/internals/#IJulia.eventloop","page":"Internals","title":"IJulia.eventloop","text":"eventloop(socket)\n\nGeneric event loop for one of the kernel sockets.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.waitloop","page":"Internals","title":"IJulia.waitloop","text":"waitloop()\n\nMain loop of a kernel. Runs the event loops for the control and shell sockets (note: in IJulia the shell socket is called requests).\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IO","page":"Internals","title":"IO","text":"","category":"section"},{"location":"library/internals/#IJulia.IJuliaStdio","page":"Internals","title":"IJulia.IJuliaStdio","text":"Wrapper type around redirected stdio streams, both for overloading things like flush and so that we can set properties like color.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#IJulia.capture_stdout","page":"Internals","title":"IJulia.capture_stdout","text":"The IJulia kernel captures all stdout and stderr output and redirects it to the notebook.   When debugging IJulia problems, however, it can be more convenient to not capture stdout and stderr output (since the notebook may not be functioning). This can be done by editing IJulia.jl to set capture_stderr and/or capture_stdout to false.\n\n\n\n\n\n","category":"constant"},{"location":"library/internals/#IJulia.capture_stderr","page":"Internals","title":"IJulia.capture_stderr","text":"The IJulia kernel captures all stdout and stderr output and redirects it to the notebook.   When debugging IJulia problems, however, it can be more convenient to not capture stdout and stderr output (since the notebook may not be functioning). This can be done by editing IJulia.jl to set capture_stderr and/or capture_stdout to false.\n\n\n\n\n\n","category":"constant"},{"location":"library/internals/#IJulia.watch_stream","page":"Internals","title":"IJulia.watch_stream","text":"watch_stream(rd::IO, name::AbstractString)\n\nContinually read from (size limited) Libuv/OS buffer into an IObuffer to avoid problems when the Libuv/OS buffer gets full (https://github.com/JuliaLang/julia/issues/8789). Send data immediately when buffer contains more than max_bytes bytes. Otherwise, if data is available it will be sent every stream_interval seconds (see the Timer's set up in watch_stdio). Truncate the output to max_output_per_request bytes per execution request since excessive output can bring browsers to a grinding halt.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Multimedia-display","page":"Internals","title":"Multimedia display","text":"","category":"section"},{"location":"library/internals/#IJulia.InlineDisplay","page":"Internals","title":"IJulia.InlineDisplay","text":"Struct to dispatch on for inline display.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#IJulia.InlineIOContext","page":"Internals","title":"IJulia.InlineIOContext","text":"InlineIOContext(io, KVs::Pair...)\n\nCreate an IOContext for inline display.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.ipy_mime","page":"Internals","title":"IJulia.ipy_mime","text":"Supported MIME types for inline display in IPython, in descending order of preference (descending \"richness\").\n\n\n\n\n\n","category":"constant"},{"location":"library/internals/#IJulia.ijulia_mime_types","page":"Internals","title":"IJulia.ijulia_mime_types","text":"A vector of MIME types (or vectors of MIME types) that IJulia will try to render. IJulia will try to render every MIME type specified in the first level of the vector. If a vector of MIME types is specified, IJulia will include only the first MIME type that is renderable (this allows for the expression of priority and exclusion of redundant data).\n\nFor example, since \"text/plain\" is specified as a first-child of the array, IJulia will always try to include a \"text/plain\" representation of anything that is displayed. Since markdown and html are specified within a sub-vector, IJulia will always try to render \"text/markdown\", and will only try to render \"text/html\" if markdown isn't possible.\n\n\n\n\n\n","category":"constant"},{"location":"library/internals/#IJulia.ijulia_jsonmime_types","page":"Internals","title":"IJulia.ijulia_jsonmime_types","text":"MIME types that when rendered (via stringmime) return JSON data. See ijulia_mime_types for a description of how MIME types are selected.\n\nThis is necessary to embed the JSON as is in the displaydata bundle (rather than as stringify'd JSON).\n\n\n\n\n\n","category":"constant"},{"location":"library/internals/#IJulia.limitstringmime","page":"Internals","title":"IJulia.limitstringmime","text":"limitstringmime(mime::MIME, x, forcetext=false)\n\nConvert x to a string of type mime, making sure to use an IOContext that tells the underlying show function to limit output.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.israwtext","page":"Internals","title":"IJulia.israwtext","text":"Need special handling for showing a string as a textmime type, since in that case the string is assumed to be raw data unless it is text/plain.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.display_dict","page":"Internals","title":"IJulia.display_dict","text":"Generate a dictionary of mime_type => data pairs for all registered MIME types. This is the format that Jupyter expects in display_data and execute_result messages.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.display_mimejson","page":"Internals","title":"IJulia.display_mimejson","text":"Generate the preferred json-MIME representation of x.\n\nReturns a tuple with the selected MIME type and the representation of the data using that MIME type (as a JSONText).\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.display_mimestring","page":"Internals","title":"IJulia.display_mimestring","text":"Generate the preferred MIME representation of x.\n\nReturns a tuple with the selected MIME type and the representation of the data using that MIME type.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.register_mime","page":"Internals","title":"IJulia.register_mime","text":"register_mime(x::Union{MIME, Vector{MIME}})\nregister_mime(x::AbstractVector{<:MIME})\n\nRegister a new MIME type.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.register_jsonmime","page":"Internals","title":"IJulia.register_jsonmime","text":"register_jsonmime(x::Union{MIME, Vector{MIME}})\nregister_jsonmime(x::AbstractVector{<:MIME})\n\nRegister a new JSON MIME type.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Jupyter","page":"Internals","title":"Jupyter","text":"","category":"section"},{"location":"library/internals/#IJulia.find_jupyter_subcommand","page":"Internals","title":"IJulia.find_jupyter_subcommand","text":"find_jupyter_subcommand(subcommand::AbstractString, port::Union{Nothing,Int}=nothing)\n\nReturn a Cmd for the program subcommand. If the program is jupyter or jupyterlab it may prompt the user to install it.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.launch","page":"Internals","title":"IJulia.launch","text":"launch(cmd, dir, detached, verbose)\n\nRun cmd in dir. If detached is false it will not wait for the command to finish. If verbose is true then the stdout/stderr from the cmd process will be echoed to stdout/stderr.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Debugging","page":"Internals","title":"Debugging","text":"","category":"section"},{"location":"library/internals/#IJulia.set_verbose","page":"Internals","title":"IJulia.set_verbose","text":"set_verbose(v=true)\n\nThis function enables (or disables, for set_verbose(false)) verbose output from the IJulia kernel, when called within a running notebook. This consists of log messages printed to the terminal window where jupyter was launched, displaying information about every message sent or received by the kernel.   Used for debugging IJulia.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Utility","page":"Internals","title":"Utility","text":"","category":"section"},{"location":"library/internals/#IJulia.num_utf8_trailing","page":"Internals","title":"IJulia.num_utf8_trailing","text":"If d ends with an incomplete UTF8-encoded character, return the number of trailing incomplete bytes. Otherwise, return 0.\n\n\n\n\n\n","category":"function"},{"location":"manual/running/#Running-IJulia","page":"Running IJulia","title":"Running IJulia","text":"","category":"section"},{"location":"manual/running/#Running-the-IJulia-Notebook","page":"Running IJulia","title":"Running the IJulia Notebook","text":"","category":"section"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"If you are comfortable managing your own Python/Jupyter installation, you can just run jupyter notebook yourself in a terminal.   To simplify installation, however, you can alternatively type the following in Julia, at the julia> prompt:","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"using IJulia\nnotebook()","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"to launch the IJulia notebook in your browser.","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"The first time you run notebook(), it will prompt you for whether it should install Jupyter.  Hit enter to have it use the Conda.jl package to install a minimal Python+Jupyter distribution (via Miniconda) that is private to Julia (not in your PATH). On Linux, it defaults to looking for jupyter in your PATH first, and only asks to installs the Conda Jupyter if that fails; you can force it to use Conda on Linux by setting ENV[\"JUPYTER\"]=\"\" during installation (see above).  (In a Debian or Ubuntu  GNU/Linux system, install the package jupyter-client to install the system jupyter.)","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"You can use notebook(detached=true) to launch a notebook server in the background that will persist even when you quit Julia. This is also useful if you want to keep using the current Julia session instead of opening a new one.","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"using IJulia; notebook(detached=true)","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"By default, the notebook \"dashboard\" opens in your home directory (homedir()), but you can open the dashboard in a different directory with notebook(dir=\"/some/path\").","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"Alternatively, you can run","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"jupyter notebook","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"from the command line (the Terminal program in MacOS or the Command Prompt in Windows). Note that if you installed jupyter via automated Miniconda installer in Pkg.add, above, then jupyter may not be in your PATH; type import Conda; Conda.SCRIPTDIR in Julia to find out where Conda installed jupyter.","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"A \"dashboard\" window like this should open in your web browser.  Click on the New button and choose the Julia option to start a new \"notebook\".  A notebook will combine code, computed results, formatted text, and images, just as in IPython.  You can enter multiline input cells and execute them with shift-ENTER, and the menu items are mostly self-explanatory.  Refer to the Jupyter notebook documentation for more information, and see also the \"Help\" menu in the notebook itself.","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"Given an IJulia notebook file, you can execute its code within any other Julia file (including another notebook) via the NBInclude package.","category":"page"},{"location":"manual/running/#Running-the-JupyterLab","page":"Running IJulia","title":"Running the JupyterLab","text":"","category":"section"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"Instead of running the classic notebook interface, you can use the IDE-like JupyterLab. If you are comfortable managing your own JupyterLab installation, you can just run jupyter lab yourself in a terminal.   To simplify installation, however, you can alternatively type the following in Julia, at the julia> prompt:","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"using IJulia\njupyterlab()","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"Like notebook(), above, this will install JupyterLab via Conda if it is not installed already.   jupyterlab() also supports detached and dir keyword options similar to notebook().","category":"page"},{"location":"manual/running/#Running-nteract","page":"Running IJulia","title":"Running nteract","text":"","category":"section"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"The nteract Desktop is an application that lets you work with notebooks without a Python installation. First, install IJulia (but do not run notebook() unless you want a Python installation) and then nteract.","category":"page"},{"location":"manual/running/#Other-IPython-interfaces","page":"Running IJulia","title":"Other IPython interfaces","text":"","category":"section"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"Most people will use the notebook (browser-based) interface, but you can also use the IPython qtconsole or IPython terminal interfaces by running ipython qtconsole --kernel julia-0.7 or ipython console --kernel julia-0.7, respectively. (Replace 0.7 with whatever major Julia version you are using.)","category":"page"},{"location":"manual/troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"manual/troubleshooting/#General-troubleshooting-tips","page":"Troubleshooting","title":"General troubleshooting tips","text":"","category":"section"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you ran into a problem with the above steps, after fixing the problem you can type Pkg.build() to try to rerun the install scripts.\nIf you tried it a while ago, try running Pkg.update() and try again: this will fetch the latest versions of the Julia packages in case the problem you saw was fixed.  Run Pkg.build(\"IJulia\") if your Julia version may have changed.  If this doesn't work, you could try just deleting the whole .julia/conda directory in your home directory (on Windows, it is called Users\\USERNAME\\.julia\\conda in your home directory) via rm(abspath(first(DEPOT_PATH), \"conda\"),recursive=true) in Julia and re-adding the packages. \nOn MacOS, you currently need MacOS 10.7 or later; MacOS 10.6 doesn't work (unless you compile Julia yourself, from source code).\nInternet Explorer 8 (the default in Windows 7) or 9 don't work with the notebook; use Firefox (6 or later) or Chrome (13 or later).  Internet Explorer 10 in Windows 8 works (albeit with a few rendering glitches), but Chrome or Firefox is better.\nIf the notebook opens up, but doesn't respond (the input label is In[*] indefinitely), try creating a new Python notebook (not Julia) from the New button in the Jupyter dashboard, to see if 1+1 works in Python.  If it is the same problem, then probably you have a firewall running on your machine (this is common on Windows) and you need to disable the firewall or at least to allow the IP address 127.0.0.1.  (For the Sophos endpoint security software, go to \"Configure Anti-Virus and HIPS\", select \"Authorization\" and then \"Websites\", and add 127.0.0.1 to \"Authorized websites\"; finally, restart your computer.) If the Python test works, then IJulia may not be installed in the global or default environment and you may need to install a custom Julia kernel that uses your required Project.toml (see Julia projects).\nTry running jupyter --version and make sure that it prints 3.0.0 or larger; earlier versions of IPython are no longer supported by IJulia.\nYou can try setting ENV[\"JUPYTER\"]=\"\"; Pkg.build(\"IJulia\") to force IJulia to go back to its own Conda-based Jupyter version (if you previously tried a different jupyter).","category":"page"},{"location":"manual/troubleshooting/#Debugging-IJulia-problems","page":"Troubleshooting","title":"Debugging IJulia problems","text":"","category":"section"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If IJulia is crashing (e.g. it gives you a \"kernel appears to have died\" message), you can modify it to print more descriptive error messages to the terminal by doing:","category":"page"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ENV[\"IJULIA_DEBUG\"]=true\nPkg.build(\"IJulia\")","category":"page"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Restart the notebook and look for the error message when IJulia dies. (This changes IJulia to default to verbose = true mode, and sets capture_stderr = false, hopefully sending a bunch of debugging to the terminal where you launched jupyter).","category":"page"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"When you are done, set ENV[\"IJULIA_DEBUG\"]=false and re-run Pkg.build(\"IJulia\") to turn off the debugging output.","category":"page"},{"location":"#IJulia","page":"Home","title":"IJulia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IJulia is a Julia-language backend combined with the Jupyter interactive environment (also used by IPython).  This combination allows you to interact with the Julia language using Jupyter/IPython's powerful graphical notebook, which combines code, formatted text, math, and multimedia in a single document.  It also works with JupyterLab, a Jupyter-based integrated development environment for notebooks and code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(IJulia notebooks can also be re-used in other Julia code via the NBInclude package.)","category":"page"},{"location":"library/public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"library/public/#General","page":"Public API","title":"General","text":"","category":"section"},{"location":"library/public/#IJulia.IJulia","page":"Public API","title":"IJulia.IJulia","text":"IJulia is a Julia-language backend combined with the Jupyter interactive environment (also used by IPython).  This combination allows you to interact with the Julia language using Jupyter/IPython's powerful graphical notebook, which combines code, formatted text, math, and multimedia in a single document.\n\nThe IJulia module is used in three ways\n\nTyping using IJulia; notebook() will launch the Jupyter notebook interface in your web browser.  This is an alternative to launching jupyter notebook directly from your operating-system command line.\nIn a running notebook, the IJulia module is loaded and IJulia.somefunctions can be used to interact with the running IJulia kernel:\nIJulia.load(filename) and IJulia.load_string(s) load the contents of a file or a string, respectively, into a notebook cell.\nIJulia.clear_output() to clear the output from the notebook cell, useful for simple animations.\nIJulia.clear_history() to clear the history variables In and Out.\npush_X_hook(f) and pop_X_hook(f), where X is either preexecute, postexecute, or posterror.  This allows you to insert a \"hook\" function into a list of functions to execute when notebook cells are evaluated.\nIJulia.set_verbose() enables verbose output about what IJulia is doing internally; this is mainly used for debugging.\nIt is used internally by the IJulia kernel when talking to the Jupyter server.\n\n\n\n\n\n","category":"module"},{"location":"library/public/#IJulia.inited","page":"Public API","title":"IJulia.inited","text":"inited is a global variable that is set to true if the IJulia kernel is running, i.e. in a running IJulia notebook.  To test whether you are in an IJulia notebook, therefore, you can check isdefined(Main, :IJulia) && IJulia.inited.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#IJulia.installkernel","page":"Public API","title":"IJulia.installkernel","text":"installkernel(name::AbstractString, options::AbstractString...;\n              julia::Cmd,\n              specname::AbstractString,\n              displayname::AbstractString,\n              env=Dict())\n\nInstall a new Julia kernel, where the given options are passed to the julia executable, the user-visible kernel name is given by name followed by the Julia version, and the env dictionary is added to the environment.\n\nThe new kernel name is returned by installkernel.  For example:\n\nkernelpath = installkernel(\"Julia O3\", \"-O3\", env=Dict(\"FOO\"=>\"yes\"))\n\ncreates a new Julia kernel in which julia is launched with the -O3 optimization flag and FOO=yes is included in the environment variables.\n\nThe displayname argument can be used to customize the name displayed in the Jupyter kernel list.\n\nThe returned kernelpath is the path of the installed kernel directory, something like /...somepath.../kernels/julia-o3-1.6 (in Julia 1.6).  The specname argument can be passed to alter the name of this directory (which defaults to name with spaces replaced by hyphens, and special characters other than - hyphen, . period and _ underscore replaced by _ underscores, and the Julia major and minor version appended).\n\nYou can uninstall the kernel by calling rm(kernelpath, recursive=true).\n\nYou can specify a custom command to execute Julia via keyword argument julia. For example, you may want specify that the Julia kernel is running in a Docker container (but Jupyter will run outside of it), by calling installkernel from within such a container instance like this (or similar):\n\ninstallkernel(\n    \"Julia via Docker\",\n    julia = `docker run --rm --net=host\n        --volume=/home/USERNAME/.local/share/jupyter:/home/USERNAME/.local/share/jupyter\n        some-container /opt/julia-1.x/bin/julia`\n)\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Launching-the-server","page":"Public API","title":"Launching the server","text":"","category":"section"},{"location":"library/public/#IJulia.jupyterlab","page":"Public API","title":"IJulia.jupyterlab","text":"jupyterlab(; dir=homedir(), detached=false, port::Union{Nothing,Int}=nothing, verbose=false)\n\nSimilar to IJulia.notebook() but launches JupyterLab instead of the Jupyter notebook.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.notebook","page":"Public API","title":"IJulia.notebook","text":"notebook(; dir=homedir(), detached=false, port::Union{Nothing,Int}=nothing, verbose=false)\n\nThe notebook() function launches the Jupyter notebook, and is equivalent to running jupyter notebook at the operating-system command-line.    The advantage of launching the notebook from Julia is that, depending on how Jupyter was installed, the user may not know where to find the jupyter executable.\n\nBy default, the notebook server is launched in the user's home directory, but this location can be changed by passing the desired path in the dir keyword argument.  e.g. notebook(dir=pwd()) to use the current directory.\n\nBy default, notebook() does not return; you must hit ctrl-c or quit Julia to interrupt it, which halts Jupyter.  So, you must leave the Julia terminal open for as long as you want to run Jupyter.  Alternatively, if you run notebook(detached=true), the jupyter notebook will launch in the background, and will continue running even after you quit Julia.  (The only way to stop Jupyter will then be to kill it in your operating system's process manager.)\n\nWhen the optional keyword port is not nothing, open the notebook on the given port number.\n\nIf verbose=true then the stdout/stderr from Jupyter will be echoed to the terminal. Try enabling this if you're having problems connecting to a kernel to see if there's any useful error messages from Jupyter.\n\nFor launching a JupyterLab instance, see IJulia.jupyterlab().\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.qtconsole","page":"Public API","title":"IJulia.qtconsole","text":"qtconsole()\n\nLaunches qtconsole for the current kernel. IJulia must be initialized already.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#History","page":"Public API","title":"History","text":"","category":"section"},{"location":"library/public/#IJulia.In","page":"Public API","title":"IJulia.In","text":"In is a global dictionary of input strings, where In[n] returns the string for input cell n of the notebook (as it was when it was last evaluated).\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#IJulia.Out","page":"Public API","title":"IJulia.Out","text":"Out is a global dictionary of output values, where Out[n] returns the output from the last evaluation of cell n in the notebook.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#IJulia.ans","page":"Public API","title":"IJulia.ans","text":"ans is a global variable giving the value returned by the last notebook cell evaluated.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#IJulia.n","page":"Public API","title":"IJulia.n","text":"IJulia.n is the (integer) index of the last-evaluated notebook cell.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#IJulia.clear_history","page":"Public API","title":"IJulia.clear_history","text":"clear_history([indices])\n\nThe clear_history() function clears all of the input and output history stored in the running IJulia notebook.  This is sometimes useful because all cell outputs are remember in the Out global variable, which prevents them from being freed, so potentially this could waste a lot of memory in a notebook with many large outputs.\n\nThe optional indices argument is a collection of indices indicating a subset of cell inputs/outputs to clear.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.history","page":"Public API","title":"IJulia.history","text":"history([io], [indices...])\n\nThe history() function prints all of the input history stored in the running IJulia notebook in a format convenient for copying.\n\nThe optional indices argument is one or more indices or collections of indices indicating a subset input cells to print.\n\nThe optional io argument is for specifying an output stream. The default is stdout.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Cells","page":"Public API","title":"Cells","text":"","category":"section"},{"location":"library/public/#IJulia.clear_output","page":"Public API","title":"IJulia.clear_output","text":"clear_output(wait=false)\n\nCall clear_output() to clear visible output from the current notebook cell.  Using wait=true clears the output only when new output is available, which reduces flickering and is useful for simple animations.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.load","page":"Public API","title":"IJulia.load","text":"load(filename, replace=false)\n\nLoad the file given by filename into a new input code cell in the running IJulia notebook, analogous to the %load magics in IPython. If the optional argument replace is true, then the file contents replace the current cell rather than creating a new cell.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.load_string","page":"Public API","title":"IJulia.load_string","text":"load_string(s, replace=false)\n\nLoad the string s into a new input code cell in the running IJulia notebook, somewhat analogous to the %load magics in IPython. If the optional argument replace is true, then s replaces the current cell rather than creating a new cell.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#I/O","page":"Public API","title":"I/O","text":"","category":"section"},{"location":"library/public/#IJulia.readprompt","page":"Public API","title":"IJulia.readprompt","text":"readprompt(prompt::AbstractString; password::Bool=false)\n\nDisplay the prompt string, request user input, and return the string entered by the user.  If password is true, the user's input is not displayed during typing.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.set_max_stdio","page":"Public API","title":"IJulia.set_max_stdio","text":"set_max_stdio(max_output::Integer)\n\nSets the maximum number of bytes, max_output, that can be written to stdout and stderr before getting truncated. A large value here allows a lot of output to be displayed in the notebook, potentially bogging down the browser.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Using-IJulia","page":"Using IJulia","title":"Using IJulia","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"There are various features of IJulia that allow you to interact with a running IJulia kernel.","category":"page"},{"location":"manual/usage/#General","page":"Using IJulia","title":"General","text":"","category":"section"},{"location":"manual/usage/#Detecting-that-code-is-running-under-IJulia","page":"Using IJulia","title":"Detecting that code is running under IJulia","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"If your code needs to detect whether it is running in an IJulia notebook (or other Jupyter client), it can check isdefined(Main, :IJulia) && Main.IJulia.inited.","category":"page"},{"location":"manual/usage/#Julia-projects","page":"Using IJulia","title":"Julia projects","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"The default Jupyter kernel that is installed by IJulia starts with the Julia command line flag --project=@.. A  Project.toml (or JuliaProject.toml) in the folder of a notebook (or in a parent folder of this notebook) will therefore automatically become the active project for that notebook. Users that don't want this behavior should install an additional IJulia kernel without that command line flag (see section Installing additional Julia kernels).","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"If an existing Project.toml file is not found then, by default, an IJulia notebook will try to run a Julia kernel with its active project set from the global or default environment (usually of the form ~/.julia/environments/v1.x). If the IJulia package is not installed in that environment, then the Julia kernel selected by default will not be able to connect, and a Connection failed error will be displayed. In this case, users should install a additional Julia kernel that uses their chosen Julia environment. For example, if the desired environment is currently activated in the REPL then one possibility is to execute","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"IJulia.installkernel(\"Julia MyProjectEnv\", \"--project=$(Base.active_project())\")","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"and subsequently select the kernel starting with Julia MyProjectEnv from Kernel > Change Kernel in the menu of the Jupyter notebook.","category":"page"},{"location":"manual/usage/#Customizing-your-IJulia-environment","page":"Using IJulia","title":"Customizing your IJulia environment","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"If you want to run code every time you start IJulia-but only when in IJulia-add a startup_ijulia.jl file to your Julia config directory, e.g., ~/.julia/config/startup_ijulia.jl.","category":"page"},{"location":"manual/usage/#Julia-and-IPython-Magics","page":"Using IJulia","title":"Julia and IPython Magics","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"One difference from IPython is that the IJulia kernel does not use \"magics\", which are special commands prefixed with % or %% to execute code in a different language.   Instead, other syntaxes to accomplish the same goals are more natural in Julia, work in environments outside of IJulia code cells, and are often more powerful.","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"However, if you enter an IPython magic command in an IJulia code cell, it will print help explaining how to achieve a similar effect in Julia if possible. For example, the analogue of IPython's %load filename in IJulia is IJulia.load(\"filename\").","category":"page"},{"location":"manual/usage/#Input-and-output","page":"Using IJulia","title":"Input and output","text":"","category":"section"},{"location":"manual/usage/#Prompting-for-user-input","page":"Using IJulia","title":"Prompting for user input","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"When you are running in a notebook, ordinary I/O functions on stdin do not function.   However, you can prompt for the user to enter a string in one of two ways:","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"readline() and readline(stdin) both open a stdin> prompt widget where the user can enter a string, which is returned by readline.\nIJulia.readprompt(prompt) displays the prompt string prompt and returns a string entered by the user.  IJulia.readprompt(prompt, password=true) does the same thing but hides the text the user types.","category":"page"},{"location":"manual/usage/#Clearing-output","page":"Using IJulia","title":"Clearing output","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"Analogous to the IPython.display.clear_output() function in IPython, IJulia provides a function:","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"IJulia.clear_output(wait=false)","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"to clear the output from the current input cell.  If the optional wait argument is true, then the front-end waits to clear the output until a new output is available to replace it (to minimize flickering).  This is useful to make simple animations, via repeated calls to IJulia.clear_output(true) followed by calls to display(...) to display a new animation frame.","category":"page"},{"location":"manual/usage/#Input-and-output-history","page":"Using IJulia","title":"Input and output history","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"IJulia will store dictionaries of the user's input and output history for each session in exported variables called In and Out. To recall old inputs and outputs, simply index into them, e.g. In[1] or Out[5]. Sometimes, a user may find themselves outputting large matrices or other datastructures which will be stored in Out and hence not garbage collected, possibly hogging memory. If you find that IJulia is using too much memory after generating large outputs, empty this output dictionary:","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"empty!(Out)","category":"page"},{"location":"manual/usage/#Default-display-size","page":"Using IJulia","title":"Default display size","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"When Julia displays a large data structure such as a matrix, by default it truncates the display to a given number of lines and columns.  In IJulia, this truncation is to 30 lines and 80 columns by default.   You can change this default by the LINES and COLUMNS environment variables, respectively, which can also be changed within IJulia via ENV (e.g. ENV[\"LINES\"] = 60). (Like in the REPL, you can also display non-truncated data structures via print(x).)","category":"page"},{"location":"manual/usage/#Preventing-truncation-of-output","page":"Using IJulia","title":"Preventing truncation of output","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"The new default behavior of IJulia is to truncate stdout (via show or println) after 512kb. This to prevent browsers from getting bogged down when displaying the results. This limit can be increased to a custom value, like 1MB, as follows","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"IJulia.set_max_stdio(1 << 20)","category":"page"},{"location":"manual/usage/#Execution","page":"Using IJulia","title":"Execution","text":"","category":"section"},{"location":"manual/usage/#Setting-the-current-module","page":"Using IJulia","title":"Setting the current module","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"The module that code in an input cell is evaluated in can be set using Main.IJulia.set_current_module(::Module). It defaults to Main.","category":"page"},{"location":"manual/usage/#Opting-out-of-soft-scope","page":"Using IJulia","title":"Opting out of soft scope","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"By default, IJulia evaluates user code using \"soft\" global scope, via the SoftGlobalScope.jl package: this means that you don't need explicit global declarations to modify global variables in for loops and similar, which is convenient for interactive use.","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"To opt out of this behavior, making notebooks behave similarly to global code in Julia .jl files, you can set IJulia.SOFTSCOPE[] = false at runtime, or include the environment variable IJULIA_SOFTSCOPE=no environment of the IJulia kernel when it is launched.","category":"page"}]
}
