var documenterSearchIndex = {"docs":
[{"location":"manual/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"manual/installation/#Installing-IJulia","page":"Installation","title":"Installing IJulia","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Go to the Julia Install page.\nFollow the instructions recommended to install Julia and the juliaup tool.\nRun the Julia application by double-clicking on the icon or running julia in a terminal. This will open the Julia REPL and a window with a julia> prompt will appear.\nAt the julia> prompt, install IJulia by typing:\nusing Pkg\nPkg.add(\"IJulia\")","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"info: Info\nThis process installs a kernel specification for IJulia. The IJulia kernelspec, shorthand for kernel specification, contains the instructions for launching a Julia kernel that a notebook frontend (Jupyter, JupyterLab, nteract) can use. The kernelspec does not install the notebook frontend.IJulia respects the standard JUPYTER_DATA_DIR environment variable, so you can set that before installation if you want the kernel to be installed in a specific location.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"warning: Warning\nThe command, Pkg.add(\"IJulia\"), does not install Jupyter Notebook itself.You can install Jupyter Notebook by following the Notebook's installation instructions if you want. Conveniently, Jupyter Notebook can also be installed automatically when you run IJulia.notebook().  See Running the Julia notebook.You can direct IJulia.notebook() to use a specific Jupyter installation by setting ENV[\"JUPYTER\"] to the path of the jupyter program executable. This environment variable should be set before Pkg.add or before running Pkg.build(\"IJulia\"), and it will remember your preference for subsequent updates.","category":"page"},{"location":"manual/installation/#Updating-Julia-and-IJulia","page":"Installation","title":"Updating Julia and IJulia","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Julia is improving rapidly, so it won't be long before you want to update your packages or Julia to a more recent version.  ","category":"page"},{"location":"manual/installation/#Update-packages","page":"Installation","title":"Update packages","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"To update the packages only and keep the same Julia version, run at the Julia prompt (or in IJulia):","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Pkg.update()","category":"page"},{"location":"manual/installation/#Update-Julia-and-packages","page":"Installation","title":"Update Julia and packages","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"If you download and install a new version of Julia from the Julia web site, you will also probably want to update the packages with Pkg.update() (in case newer versions of the packages are required for the most recent Julia).  In any case, if you install a new Julia binary (or do anything that changes the location of Julia on your computer), you must update the IJulia installation (to tell Jupyter where to find the new Julia) by running","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Pkg.build(\"IJulia\")","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"important: Important\nPkg.build(\"IJulia\") must be run at the Julia command line. It will error and fail if run within IJulia.","category":"page"},{"location":"manual/installation/#Installing-and-customizing-kernels","page":"Installation","title":"Installing and customizing kernels","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"You may find it helpful to run multiple Julia kernels to support different Julia executable versions and/or environment settings.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"You can install one or more custom Julia kernels by using the IJulia.installkernel function. For example, if you want to run Julia with all deprecation warnings disabled, you can create a custom IJulia kernel:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"using IJulia\ninstallkernel(\"Julia nodeps\", \"--depwarn=no\")","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"and a kernel called Julia nodeps 0.7 (if you are using Julia 0.7) will be installed (will show up in your main Jupyter kernel menu) that lets you open notebooks with this flag. Note that the default kernel that IJulia installs passes the --project=@. option to Julia, if you want to preserve this behaviour for custom kernels make sure to pass it explicitly to IJulia.installkernel:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"installkernel(\"Julia nodeps\", \"--depwarn=no\", \"--project=@.\")","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"You can also install kernels to run Julia with different environment variables, for example to set JULIA_NUM_THREADS for use with Julia multithreading:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"using IJulia\ninstallkernel(\"Julia (4 threads)\", env=Dict(\"JULIA_NUM_THREADS\"=>\"4\"))","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"The env keyword should be a Dict which maps environment variables to values.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"To prevent IJulia from installing a default kernel when the package is built, define the IJULIA_NODEFAULTKERNEL environment variable before adding or building IJulia.","category":"page"},{"location":"manual/installation/#Low-level-IPython-Installations","page":"Installation","title":"Low-level IPython Installations","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"We recommend using IPython 7.15 or later as well as Python 3.","category":"page"},{"location":"manual/installation/#Using-legacy-IPython-2.x-version","page":"Installation","title":"Using legacy IPython 2.x version","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"We recognize that some users may need to use legacy IPython 2.x.  You can do this by checkout out the ipython2 branch of the IJulia package:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Pkg.checkout(\"IJulia\", \"ipython2\")\nPkg.build(\"IJulia\")","category":"page"},{"location":"manual/installation/#Manual-installation-of-IPython","page":"Installation","title":"Manual installation of IPython","text":"","category":"section"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"First, you will need to install a few prerequisites:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"You need version 3.0 or later of IPython, or version 4 or later of Jupyter.  Note that IPython 3.0 was released in February 2015, so if you have an older operating system you may have to install IPython manually. On Mac and Windows systems, it is currently easiest to use the Anaconda Python installer.\nTo use the IPython notebook interface, which runs in your web browser and provides a rich multimedia environment, you will need to install the jsonschema, Jinja2, Tornado, and pyzmq (requires apt-get install libzmq-dev and possibly pip install --upgrade --force-reinstall pyzmq on Ubuntu if you are using pip) Python packages. (Given the pip installer, pip install jsonschema jinja2 tornado pyzmq should normally be sufficient.)  These should have been automatically installed if you installed IPython itself via easy_install or pip.\nTo use the IPython qtconsole interface, you will need to install PyQt4 or PySide.\nYou need Julia version 0.7 or later.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Once IPython 3.0+ and Julia 0.7+ are installed, you can install IJulia from a Julia console by typing:","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"Pkg.add(\"IJulia\")","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"This will download IJulia and a few other prerequisites, and will set up a Julia kernel for IPython.","category":"page"},{"location":"manual/installation/","page":"Installation","title":"Installation","text":"If the command above returns an error, you may need to run Pkg.update(), then retry it, or possibly run Pkg.build(\"IJulia\") to force a rebuild.","category":"page"},{"location":"_changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"This documents notable changes in IJulia.jl. The format is based on Keep a Changelog.","category":"page"},{"location":"_changelog/#Unreleased","page":"Changelog","title":"Unreleased","text":"","category":"section"},{"location":"_changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"Implemented a PythonCall.jl extension to support interactive ipywidgets and matplotlib widgets in Julia ([#1190]).","category":"page"},{"location":"_changelog/#[v1.30.6]-2025-10-06","page":"Changelog","title":"[v1.30.6] - 2025-10-06","text":"","category":"section"},{"location":"_changelog/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"It's now possible to register hooks at any time, even if an IJulia kernel is not running ([#1188]). This was accidentally broken in v1.30.","category":"page"},{"location":"_changelog/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"Implemented lazy loading for Conda.jl ([#1187]), which shaves off about 60% of the load time (~0.21s to ~0.08s on Julia 1.12).","category":"page"},{"location":"_changelog/#[v1.30.5]-2025-10-03","page":"Changelog","title":"[v1.30.5] - 2025-10-03","text":"","category":"section"},{"location":"_changelog/#Fixed-2","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"Fixed a major performance regression in message hashing from the switch to SHA.jl in v1.29.1, which particularly affected things like plot/dataframe outputs ([#1185]).","category":"page"},{"location":"_changelog/#[v1.30.4]-2025-09-08","page":"Changelog","title":"[v1.30.4] - 2025-09-08","text":"","category":"section"},{"location":"_changelog/#Fixed-3","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"Fixed usage of In and Out so that they actually contain the cell history instead of just being empty ([#1182]). This was accidentally broken in v1.30.0.","category":"page"},{"location":"_changelog/#[v1.30.3]-2025-09-02","page":"Changelog","title":"[v1.30.3] - 2025-09-02","text":"","category":"section"},{"location":"_changelog/#Fixed-4","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"Modified the internal IJuliaStdio struct to be deepcopy-able, which was inadvertently broken in v1.30.0 ([#1180]).","category":"page"},{"location":"_changelog/#[v1.30.2]-2025-08-29","page":"Changelog","title":"[v1.30.2] - 2025-08-29","text":"","category":"section"},{"location":"_changelog/#Changed-2","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"Implemented lazy loading for Pkg.jl ([#1177]), which significantly cuts down the load time (~0.75s to ~0.25s on Julia 1.11). Also made various other improvements to precompilation and inference to improve TTFX.","category":"page"},{"location":"_changelog/#[v1.30.1]-2025-08-27","page":"Changelog","title":"[v1.30.1] - 2025-08-27","text":"","category":"section"},{"location":"_changelog/#Fixed-5","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"Added the default value kernel=_default_kernel to the function set_max_stdio, which fixes a breaking change introduced in v1.30.0 ([#1178]).","category":"page"},{"location":"_changelog/#[v1.30.0]-2025-08-24","page":"Changelog","title":"[v1.30.0] - 2025-08-24","text":"","category":"section"},{"location":"_changelog/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"Implemented reset_stdio_count() to provide a public API for resetting the stdio count ([#1145]).\nA precompilation workload was added to improve TTFX ([#1145], [#1174]).","category":"page"},{"location":"_changelog/#Changed-3","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"IJulia was completely refactored to minimize global state ([#1145]). This allows for better testing (for the first time we can test kernel execution) and for executing precompilation workloads. We've tried to avoid any breaking changes but it's possible that some packages may be relying on internals that have changed. If you have any problems with this release please open an issue on Github so we can help.\nhistory() now prints each entry on a new line ([#1145]).","category":"page"},{"location":"_changelog/#[v1.29.2]-2025-07-29","page":"Changelog","title":"[v1.29.2] - 2025-07-29","text":"","category":"section"},{"location":"_changelog/#Fixed-6","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"Fixed a typo in the tooltip lookup code ([#1171]).","category":"page"},{"location":"_changelog/#[v1.29.1]-2025-07-26","page":"Changelog","title":"[v1.29.1] - 2025-07-26","text":"","category":"section"},{"location":"_changelog/#Changed-4","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"Improved the token-finding functionality to return more accurate tooltips when Shift + Tab is pressed ([#847]).\nIJulia switched from using MbedTLS.jl to the SHA.jl stdlib. This should not change anything for users except that now only SHA message digests are supported instead of e.g. MD5, and Jupyter uses SHA256 by default ([#1170]).","category":"page"},{"location":"_changelog/#[v1.29.0]-2025-06-13","page":"Changelog","title":"[v1.29.0] - 2025-06-13","text":"","category":"section"},{"location":"_changelog/#Added-3","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"Added an args argument to notebook() and jupyterlab() to allow passing custom arguments to the underlying commands ([#1164]).","category":"page"},{"location":"_changelog/#Fixed-7","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"Fixed handling of the Jupyter process in notebook() and jupyterlab() when Ctrl + C'ing to shutdown the server, now any running kernels will be cleanly shutdown as well ([#1165]).","category":"page"},{"location":"_changelog/#[v1.28.1]-2025-06-02","page":"Changelog","title":"[v1.28.1] - 2025-06-02","text":"","category":"section"},{"location":"_changelog/#Fixed-8","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"Fixed a deadlock in the shutdown_request handler that would cause the kernel to hang when exiting ([#1163]).","category":"page"},{"location":"_changelog/#[v1.28.0]-2025-06-01","page":"Changelog","title":"[v1.28.0] - 2025-06-01","text":"","category":"section"},{"location":"_changelog/#Added-4","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"notebook() and jupyterlab() now support a verbose keyword argument to echo output from Jupyter to the terminal, which can be useful when debugging kernels ([#1157]).","category":"page"},{"location":"_changelog/#Changed-5","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"IJulia no longer uses a standalone kernel.jl file to launch the kernel, it instead calls a function inside the IJulia module. This means that kernel specs don't use absolute paths anymore and it's not necessary to rebuild IJulia after updating the package ([#1158]).\nColors in stacktraces are now displayed properly in Jupyter ([#1161]).","category":"page"},{"location":"_changelog/#Fixed-9","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"The Julia major and minor version are no longer appended to a custom specname in installkernel(). The default specname that derives from name and appends the Julia version remains unchanged ([#1154]).\nFixed adding multiple packages in Pkg mode ([#1160]).\nFixed an edge-case in inspection requests that would cause autocompletion to not work properly ([#1159]).","category":"page"},{"location":"_changelog/#[v1.27.0]-2025-04-01","page":"Changelog","title":"[v1.27.0] - 2025-04-01","text":"","category":"section"},{"location":"_changelog/#Added-5","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"installkernel() now supports a displayname argument to customize the kernel display name ([#1137]).","category":"page"},{"location":"_changelog/#Fixed-10","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"_changelog/","page":"Changelog","title":"Changelog","text":"The internal heartbeat thread will now shut down cleanly ([#1135], [#1144], [#1150]). This should prevent segfaults upon exit.\nVarious fixes to the messaging code to be compliant with Jupyter ([#1138], [#1150]).\nImproved threadsafety of the IO-handling code so that it should be safe to call flush() concurrently ([#1149]).","category":"page"},{"location":"changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"This documents notable changes in IJulia.jl. The format is based on Keep a Changelog.","category":"page"},{"location":"changelog/#Unreleased","page":"Changelog","title":"Unreleased","text":"","category":"section"},{"location":"changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Implemented a PythonCall.jl extension to support interactive ipywidgets and matplotlib widgets in Julia (#1190).","category":"page"},{"location":"changelog/#[v1.30.6](https://github.com/JuliaLang/IJulia.jl/releases/tag/v1.30.6)-2025-10-06","page":"Changelog","title":"v1.30.6 - 2025-10-06","text":"","category":"section"},{"location":"changelog/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"It's now possible to register hooks at any time, even if an IJulia kernel is not running (#1188). This was accidentally broken in v1.30.","category":"page"},{"location":"changelog/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Implemented lazy loading for Conda.jl (#1187), which shaves off about 60% of the load time (~0.21s to ~0.08s on Julia 1.12).","category":"page"},{"location":"changelog/#[v1.30.5](https://github.com/JuliaLang/IJulia.jl/releases/tag/v1.30.5)-2025-10-03","page":"Changelog","title":"v1.30.5 - 2025-10-03","text":"","category":"section"},{"location":"changelog/#Fixed-2","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Fixed a major performance regression in message hashing from the switch to SHA.jl in v1.29.1, which particularly affected things like plot/dataframe outputs (#1185).","category":"page"},{"location":"changelog/#[v1.30.4](https://github.com/JuliaLang/IJulia.jl/releases/tag/v1.30.4)-2025-09-08","page":"Changelog","title":"v1.30.4 - 2025-09-08","text":"","category":"section"},{"location":"changelog/#Fixed-3","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Fixed usage of In and Out so that they actually contain the cell history instead of just being empty (#1182). This was accidentally broken in v1.30.0.","category":"page"},{"location":"changelog/#[v1.30.3](https://github.com/JuliaLang/IJulia.jl/releases/tag/v1.30.3)-2025-09-02","page":"Changelog","title":"v1.30.3 - 2025-09-02","text":"","category":"section"},{"location":"changelog/#Fixed-4","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Modified the internal IJuliaStdio struct to be deepcopy-able, which was inadvertently broken in v1.30.0 (#1180).","category":"page"},{"location":"changelog/#[v1.30.2](https://github.com/JuliaLang/IJulia.jl/releases/tag/v1.30.2)-2025-08-29","page":"Changelog","title":"v1.30.2 - 2025-08-29","text":"","category":"section"},{"location":"changelog/#Changed-2","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Implemented lazy loading for Pkg.jl (#1177), which significantly cuts down the load time (~0.75s to ~0.25s on Julia 1.11). Also made various other improvements to precompilation and inference to improve TTFX.","category":"page"},{"location":"changelog/#[v1.30.1](https://github.com/JuliaLang/IJulia.jl/releases/tag/v1.30.1)-2025-08-27","page":"Changelog","title":"v1.30.1 - 2025-08-27","text":"","category":"section"},{"location":"changelog/#Fixed-5","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Added the default value kernel=_default_kernel to the function set_max_stdio, which fixes a breaking change introduced in v1.30.0 (#1178).","category":"page"},{"location":"changelog/#[v1.30.0](https://github.com/JuliaLang/IJulia.jl/releases/tag/v1.30.0)-2025-08-24","page":"Changelog","title":"v1.30.0 - 2025-08-24","text":"","category":"section"},{"location":"changelog/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Implemented reset_stdio_count() to provide a public API for resetting the stdio count (#1145).\nA precompilation workload was added to improve TTFX (#1145, #1174).","category":"page"},{"location":"changelog/#Changed-3","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"IJulia was completely refactored to minimize global state (#1145). This allows for better testing (for the first time we can test kernel execution) and for executing precompilation workloads. We've tried to avoid any breaking changes but it's possible that some packages may be relying on internals that have changed. If you have any problems with this release please open an issue on Github so we can help.\nhistory() now prints each entry on a new line (#1145).","category":"page"},{"location":"changelog/#[v1.29.2](https://github.com/JuliaLang/IJulia.jl/releases/tag/v1.29.2)-2025-07-29","page":"Changelog","title":"v1.29.2 - 2025-07-29","text":"","category":"section"},{"location":"changelog/#Fixed-6","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Fixed a typo in the tooltip lookup code (#1171).","category":"page"},{"location":"changelog/#[v1.29.1](https://github.com/JuliaLang/IJulia.jl/releases/tag/v1.29.1)-2025-07-26","page":"Changelog","title":"v1.29.1 - 2025-07-26","text":"","category":"section"},{"location":"changelog/#Changed-4","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Improved the token-finding functionality to return more accurate tooltips when Shift + Tab is pressed (#847).\nIJulia switched from using MbedTLS.jl to the SHA.jl stdlib. This should not change anything for users except that now only SHA message digests are supported instead of e.g. MD5, and Jupyter uses SHA256 by default (#1170).","category":"page"},{"location":"changelog/#[v1.29.0](https://github.com/JuliaLang/IJulia.jl/releases/tag/v1.29.0)-2025-06-13","page":"Changelog","title":"v1.29.0 - 2025-06-13","text":"","category":"section"},{"location":"changelog/#Added-3","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Added an args argument to notebook() and jupyterlab() to allow passing custom arguments to the underlying commands (#1164).","category":"page"},{"location":"changelog/#Fixed-7","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Fixed handling of the Jupyter process in notebook() and jupyterlab() when Ctrl + C'ing to shutdown the server, now any running kernels will be cleanly shutdown as well (#1165).","category":"page"},{"location":"changelog/#[v1.28.1](https://github.com/JuliaLang/IJulia.jl/releases/tag/v1.28.1)-2025-06-02","page":"Changelog","title":"v1.28.1 - 2025-06-02","text":"","category":"section"},{"location":"changelog/#Fixed-8","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Fixed a deadlock in the shutdown_request handler that would cause the kernel to hang when exiting (#1163).","category":"page"},{"location":"changelog/#[v1.28.0](https://github.com/JuliaLang/IJulia.jl/releases/tag/v1.28.0)-2025-06-01","page":"Changelog","title":"v1.28.0 - 2025-06-01","text":"","category":"section"},{"location":"changelog/#Added-4","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"notebook() and jupyterlab() now support a verbose keyword argument to echo output from Jupyter to the terminal, which can be useful when debugging kernels (#1157).","category":"page"},{"location":"changelog/#Changed-5","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"IJulia no longer uses a standalone kernel.jl file to launch the kernel, it instead calls a function inside the IJulia module. This means that kernel specs don't use absolute paths anymore and it's not necessary to rebuild IJulia after updating the package (#1158).\nColors in stacktraces are now displayed properly in Jupyter (#1161).","category":"page"},{"location":"changelog/#Fixed-9","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The Julia major and minor version are no longer appended to a custom specname in installkernel(). The default specname that derives from name and appends the Julia version remains unchanged (#1154).\nFixed adding multiple packages in Pkg mode (#1160).\nFixed an edge-case in inspection requests that would cause autocompletion to not work properly (#1159).","category":"page"},{"location":"changelog/#[v1.27.0](https://github.com/JuliaLang/IJulia.jl/releases/tag/v1.27.0)-2025-04-01","page":"Changelog","title":"v1.27.0 - 2025-04-01","text":"","category":"section"},{"location":"changelog/#Added-5","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"installkernel() now supports a displayname argument to customize the kernel display name (#1137).","category":"page"},{"location":"changelog/#Fixed-10","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The internal heartbeat thread will now shut down cleanly (#1135, #1144, #1150). This should prevent segfaults upon exit.\nVarious fixes to the messaging code to be compliant with Jupyter (#1138, #1150).\nImproved threadsafety of the IO-handling code so that it should be safe to call flush() concurrently (#1149).","category":"page"},{"location":"library/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"library/internals/#Initialization","page":"Internals","title":"Initialization","text":"","category":"section"},{"location":"library/internals/#IJulia.init","page":"Internals","title":"IJulia.init","text":"init(args, kernel)\n\nInitialize a kernel. args may either be empty or have one element containing the path to an existing connection file. If args is empty a connection file will be generated.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Messaging","page":"Internals","title":"Messaging","text":"","category":"section"},{"location":"library/internals/#IJulia.Msg","page":"Internals","title":"IJulia.Msg","text":"IPython message struct.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#IJulia.msg_header","page":"Internals","title":"IJulia.msg_header","text":"msg_header(m::Msg, msg_type::String)\n\nCreate a header for a Msg.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.send_ipython","page":"Internals","title":"IJulia.send_ipython","text":"send_ipython(socket, kernel, m::Msg)\n\nSend a message m. This will lock socket.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.recv_ipython","page":"Internals","title":"IJulia.recv_ipython","text":"recv_ipython(socket, kernel)\n\nWait for and get a message. This will lock socket.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.set_cur_msg","page":"Internals","title":"IJulia.set_cur_msg","text":"Jupyter associates cells with message headers. Once a cell's execution state has been set as to idle, it will silently drop stream messages (i.e. output to stdout and stderr) - see https://github.com/jupyter/notebook/issues/518. When using Interact, and a widget's state changes, a new message header is sent to the IJulia kernel, and while Reactive is updating Signal graph state, it's execution state is busy, meaning Jupyter will not drop stream messages if Interact can set the header message under which the stream messages will be sent. Hence the need for this function.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.send_status","page":"Internals","title":"IJulia.send_status","text":"send_status(state::AbstractString, kernel, parent_msg::Msg=execute_msg)\n\nPublish a status message.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Request-handlers","page":"Internals","title":"Request handlers","text":"","category":"section"},{"location":"library/internals/#IJulia.connect_request","page":"Internals","title":"IJulia.connect_request","text":"connect_request(socket, kernel, msg)\n\nHandle a connect request.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.execute_request","page":"Internals","title":"IJulia.execute_request","text":"execute_request(socket, kernel, msg)\n\nHandle a execute request. This will execute Julia code, along with Pkg and shell commands.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.shutdown_request","page":"Internals","title":"IJulia.shutdown_request","text":"shutdown_request(socket, kernel, msg)\n\nHandle a shutdown request. After sending the reply this will exit the process.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.interrupt_request","page":"Internals","title":"IJulia.interrupt_request","text":"interrupt_request(socket, kernel, msg)\n\nHandle a interrupt request. This will throw an InterruptException to the currently executing request handler.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.inspect_request","page":"Internals","title":"IJulia.inspect_request","text":"inspect_request(socket, kernel, msg)\n\nHandle a introspection request.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.history_request","page":"Internals","title":"IJulia.history_request","text":"history_request(socket, kernel, msg)\n\nHandle a history request. This is currently only a dummy implementation that doesn't actually do anything.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.complete_request","page":"Internals","title":"IJulia.complete_request","text":"complete_request(socket, kernel, msg)\n\nHandle a completion request.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.kernel_info_request","page":"Internals","title":"IJulia.kernel_info_request","text":"kernel_info_request(socket, kernel, msg)\n\nHandle a kernel info request.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.is_complete_request","page":"Internals","title":"IJulia.is_complete_request","text":"is_complete_request(socket, kernel, msg)\n\nHandle a completeness request.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Event-loop","page":"Internals","title":"Event loop","text":"","category":"section"},{"location":"library/internals/#IJulia.eventloop","page":"Internals","title":"IJulia.eventloop","text":"eventloop(socket, kernel)\n\nGeneric event loop for one of the kernel sockets.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.waitloop","page":"Internals","title":"IJulia.waitloop","text":"waitloop(kernel)\n\nMain loop of a kernel. Runs the event loops for the control and shell sockets (note: in IJulia the shell socket is called requests).\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IO","page":"Internals","title":"IO","text":"","category":"section"},{"location":"library/internals/#IJulia.IJuliaStdio","page":"Internals","title":"IJulia.IJuliaStdio","text":"Wrapper type around redirected stdio streams, both for overloading things like flush and so that we can set properties like color.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#IJulia.watch_stream","page":"Internals","title":"IJulia.watch_stream","text":"watch_stream(rd::IO, name::AbstractString)\n\nContinually read from (size limited) Libuv/OS buffer into an IObuffer to avoid problems when the Libuv/OS buffer gets full (https://github.com/JuliaLang/julia/issues/8789). Send data immediately when buffer contains more than max_bytes bytes. Otherwise, if data is available it will be sent every stream_interval seconds (see the Timer's set up in watch_stdio). Truncate the output to max_output_per_request bytes per execution request since excessive output can bring browsers to a grinding halt.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Multimedia-display","page":"Internals","title":"Multimedia display","text":"","category":"section"},{"location":"library/internals/#IJulia.InlineDisplay","page":"Internals","title":"IJulia.InlineDisplay","text":"Struct to dispatch on for inline display.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#IJulia.InlineIOContext","page":"Internals","title":"IJulia.InlineIOContext","text":"InlineIOContext(io, KVs::Pair...)\n\nCreate an IOContext for inline display.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.ipy_mime","page":"Internals","title":"IJulia.ipy_mime","text":"Supported MIME types for inline display in IPython, in descending order of preference (descending \"richness\").\n\n\n\n\n\n","category":"constant"},{"location":"library/internals/#IJulia.ijulia_mime_types","page":"Internals","title":"IJulia.ijulia_mime_types","text":"A vector of MIME types (or vectors of MIME types) that IJulia will try to render. IJulia will try to render every MIME type specified in the first level of the vector. If a vector of MIME types is specified, IJulia will include only the first MIME type that is renderable (this allows for the expression of priority and exclusion of redundant data).\n\nFor example, since \"text/plain\" is specified as a first-child of the array, IJulia will always try to include a \"text/plain\" representation of anything that is displayed. Since markdown and html are specified within a sub-vector, IJulia will always try to render \"text/markdown\", and will only try to render \"text/html\" if markdown isn't possible.\n\n\n\n\n\n","category":"constant"},{"location":"library/internals/#IJulia.ijulia_jsonmime_types","page":"Internals","title":"IJulia.ijulia_jsonmime_types","text":"MIME types that when rendered (via stringmime) return JSON data. See ijulia_mime_types for a description of how MIME types are selected.\n\nThis is necessary to embed the JSON as is in the displaydata bundle (rather than as stringify'd JSON).\n\n\n\n\n\n","category":"constant"},{"location":"library/internals/#IJulia.limitstringmime","page":"Internals","title":"IJulia.limitstringmime","text":"limitstringmime(mime::MIME, x, forcetext=false)\n\nConvert x to a string of type mime, making sure to use an IOContext that tells the underlying show function to limit output.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.israwtext","page":"Internals","title":"IJulia.israwtext","text":"Need special handling for showing a string as a textmime type, since in that case the string is assumed to be raw data unless it is text/plain.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.display_dict","page":"Internals","title":"IJulia.display_dict","text":"Generate a dictionary of mime_type => data pairs for all registered MIME types. This is the format that Jupyter expects in display_data and execute_result messages.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.display_mimejson","page":"Internals","title":"IJulia.display_mimejson","text":"Generate the preferred json-MIME representation of x.\n\nReturns a tuple with the selected MIME type and the representation of the data using that MIME type (as a JSONText).\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.display_mimestring","page":"Internals","title":"IJulia.display_mimestring","text":"Generate the preferred MIME representation of x.\n\nReturns a tuple with the selected MIME type and the representation of the data using that MIME type.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.register_mime","page":"Internals","title":"IJulia.register_mime","text":"register_mime(x::Union{MIME, Vector{MIME}})\nregister_mime(x::AbstractVector{<:MIME})\n\nRegister a new MIME type.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.register_jsonmime","page":"Internals","title":"IJulia.register_jsonmime","text":"register_jsonmime(x::Union{MIME, Vector{MIME}})\nregister_jsonmime(x::AbstractVector{<:MIME})\n\nRegister a new JSON MIME type.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Jupyter","page":"Internals","title":"Jupyter","text":"","category":"section"},{"location":"library/internals/#IJulia.find_jupyter_subcommand","page":"Internals","title":"IJulia.find_jupyter_subcommand","text":"find_jupyter_subcommand(subcommand::AbstractString, port::Union{Nothing,Int}=nothing)\n\nReturn a Cmd for the program subcommand. If the program is jupyter or jupyterlab it may prompt the user to install it.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.launch","page":"Internals","title":"IJulia.launch","text":"launch(cmd, dir, detached, verbose)\n\nRun cmd in dir. If detached is false it will not wait for the command to finish. If verbose is true then the stdout/stderr from the cmd process will be echoed to stdout/stderr.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Debugging","page":"Internals","title":"Debugging","text":"","category":"section"},{"location":"library/internals/#IJulia.set_verbose","page":"Internals","title":"IJulia.set_verbose","text":"set_verbose(v=true)\n\nThis function enables (or disables, for set_verbose(false)) verbose output from the IJulia kernel, when called within a running notebook. This consists of log messages printed to the terminal window where jupyter was launched, displaying information about every message sent or received by the kernel.   Used for debugging IJulia.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#Utility","page":"Internals","title":"Utility","text":"","category":"section"},{"location":"library/internals/#IJulia.num_utf8_trailing","page":"Internals","title":"IJulia.num_utf8_trailing","text":"If d ends with an incomplete UTF8-encoded character, return the number of trailing incomplete bytes. Otherwise, return 0.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.get_token","page":"Internals","title":"IJulia.get_token","text":"get_token(code, pos)\n\nGiven a string and a cursor position, find substring to request help on by:\n\nSearching backwards for the closest token (may be invalid)\nKeep searching backwards until we find an token before an unbalanced '('  a. If (1) is not valid, store the first valid token  b. We assume a token before an unbalanced '(' is a function\nIf we find a possible function token, return this token.\nOtherwise, return the last valid token\n\nImportant Note\n\nTokens are chosen following several empirical observations instead of rigorous rules. We assume that the first valid token before left-imbalanced (more '(' than ')') parentheses is the function \"closest\" to cursor. The following examples use '|' to denote cursor, showing observations on parentheses.\n\nf()| has balanced parentheses with nothing within, thus f is the desired token.\nf(|) has imbalanced parentheses, thus f is the desired token.\nf(x|, y) gives tokens x and f. x has balanced parentheses, while f is left-imbalanced. f is desired.\nf(x)| returns f\nf(x, y)| returns f.\nf((x|)) returns f, as expected\nf(x, (|y)) returns f. This is a hack, as I deduct crossed_parentheses whenever a separator is encountered, clamped to 0!   Otherwise, x would be returned.\nf(x, (y|)), f(x, (y)|), and f(x, (y))| all behave as above. Arbitrary nesting of tuples should not cause misbehavior.\nexpr1 ; expr2, cursor in expr2 never causes search in expr1\n\nTODO: detect operators? More robust parsing using the Julia parser instead of string hacks?\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#IJulia.get_previous_token","page":"Internals","title":"IJulia.get_previous_token","text":"get_previous_token(code, pos, crossed_parentheses)\n\nGiven a string and a cursor position, find substring corresponding to previous token. crossed_parentheses:Int keeps track of how many parentheses have been crossed. A pair of parentheses yields 0 crossing; a '(' add 1; a ')' subtracts 1.\n\nReturns (startpos, endpos, crossed_parentheses, stop)\n\nstartpos is the start position of the closest potential token before pos.\nendpos is end position if said token is can be valid identifier, or -1 otherwise\ncrossed_parentheses is the new count for parentheses.\nstop is true if ';' is hit, denoting the beginning of a clause.\n\n\n\n\n\n","category":"function"},{"location":"manual/running/#Running-IJulia","page":"Running IJulia","title":"Running IJulia","text":"","category":"section"},{"location":"manual/running/#Running-the-IJulia-Notebook","page":"Running IJulia","title":"Running the IJulia Notebook","text":"","category":"section"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"If you are comfortable managing your own Python/Jupyter installation, you can just run jupyter notebook yourself in a terminal.   To simplify installation, however, you can alternatively type the following in Julia, at the julia> prompt:","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"using IJulia\nnotebook()","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"to launch the IJulia notebook in your browser.","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"The first time you run notebook(), it will prompt you for whether it should install Jupyter.  Hit enter to have it use the Conda.jl package to install a minimal Python+Jupyter distribution (via Miniconda) that is private to Julia (not in your PATH).  On Linux, it defaults to looking for jupyter in your PATH first, and only asks to installs the Conda Jupyter if that fails; you can force notebook() to use an existing environment on Linux by setting ENV[\"JUPYTER\"] = \"/path/to/jupyter\" during the installation of IJulia (see above).  (In a Debian or Ubuntu GNU/Linux system, install the package jupyter-client to install the system jupyter.)","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"You can use notebook(detached=true) to launch a notebook server in the background that will persist even when you quit Julia. This is also useful if you want to keep using the current Julia session instead of opening a new one.","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"using IJulia; notebook(detached=true)","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"By default, the notebook \"dashboard\" opens in your home directory (homedir()), but you can open the dashboard in a different directory with notebook(dir=\"/some/path\").","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"Alternatively, you can run","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"jupyter notebook","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"from the command line (the Terminal program in MacOS or the Command Prompt in Windows). Note that if you installed jupyter via automated Miniconda installer in Pkg.add, above, then jupyter may not be in your PATH; type import Conda; Conda.SCRIPTDIR in Julia to find out where Conda installed jupyter.","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"A \"dashboard\" window like this should open in your web browser.  Click on the New button and choose the Julia option to start a new \"notebook\".  A notebook will combine code, computed results, formatted text, and images, just as in IPython.  You can enter multiline input cells and execute them with shift-ENTER, and the menu items are mostly self-explanatory.  Refer to the Jupyter notebook documentation for more information, and see also the \"Help\" menu in the notebook itself.","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"Given an IJulia notebook file, you can execute its code within any other Julia file (including another notebook) via the NBInclude package.","category":"page"},{"location":"manual/running/#Running-the-JupyterLab","page":"Running IJulia","title":"Running the JupyterLab","text":"","category":"section"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"Instead of running the classic notebook interface, you can use the IDE-like JupyterLab. If you are comfortable managing your own JupyterLab installation, you can just run jupyter lab yourself in a terminal.   To simplify installation, however, you can alternatively type the following in Julia, at the julia> prompt:","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"using IJulia\njupyterlab()","category":"page"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"Like notebook(), above, this will install JupyterLab via Conda if it is not installed already.   jupyterlab() also supports detached and dir keyword options similar to notebook().","category":"page"},{"location":"manual/running/#Running-nteract","page":"Running IJulia","title":"Running nteract","text":"","category":"section"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"The nteract Desktop is an application that lets you work with notebooks without a Python installation. First, install IJulia (but do not run notebook() unless you want a Python installation) and then nteract.","category":"page"},{"location":"manual/running/#Other-IPython-interfaces","page":"Running IJulia","title":"Other IPython interfaces","text":"","category":"section"},{"location":"manual/running/","page":"Running IJulia","title":"Running IJulia","text":"Most people will use the notebook (browser-based) interface, but you can also use the IPython qtconsole or IPython terminal interfaces by running ipython qtconsole --kernel julia-0.7 or ipython console --kernel julia-0.7, respectively. (Replace 0.7 with whatever major Julia version you are using.)","category":"page"},{"location":"manual/troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Jupyter notebooks run code by connecting to a kernel. That's exactly what the IJulia package provides. Jupyter knows about available kernels through kernel specs, which are kernel.json files inside Jupyter's data paths. You can list the available kernel specs on the command line with","category":"page"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"jupyter kernelspec list","category":"page"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Or, explore the data directory relevant to your system, e.g., ~/.local/share/jupyter/kernels.","category":"page"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Make sure that you can find a Julia kernel. If you can't, run IJulia.installkernel, e.g., as import IJulia; IJulia.installkernel(\"Julia\", \"--project=@.\") in the Julia REPL.","category":"page"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The kernel.json file for the IJulia kernel should look something like this:","category":"page"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"{\n  \"display_name\": \"Julia 1.11.5\",\n  \"argv\": [\n    \"/home/user/.julia/juliaup/julia-1.11.5+0.x64.linux.gnu/bin/julia\",\n    \"-i\",\n    \"--color=yes\",\n    \"--project=@.\",\n    \"-e\",\n    \"import IJulia; IJulia.run_kernel()\",\n    \"{connection_file}\"\n  ],\n  \"language\": \"julia\",\n  \"env\": {},\n  \"interrupt_mode\": \"signal\"\n}","category":"page"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Note the reference to the julia executable in line 4, and the call to IJulia.run_kernel() in line 9. There isn't much magical about kernels. All that happens when Jupyter starts the kernel based on a specific kernel spec is that it runs the process given by argv. That is, it runs julia with the given command line arguments. It then expects that it can talk to the resulting process with a specific messaging protocol. Here, the code in run_kernel() exposes the implementation of that protocol.","category":"page"},{"location":"manual/troubleshooting/#Kernel-connection-failure-tips","page":"Troubleshooting","title":"Kernel connection failure tips","text":"","category":"section"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Fundamentally, if the IJulia kernel fails to connect, it is most likely due to one of the following two issues:","category":"page"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The julia executable no longer exists (maybe you updated your installed Julia versions).\nThe environment that the julia executable runs in does not have the IJulia package installed. This is a common error. In general, the IJulia package should be installed in the base environment of your Julia installation (what you get when you type ] activate into the REPL without any further options, or when you simply start the Julia REPL without any options). Note that the --project=@. option in the above kernel.json falls back to the base environment, so it should generally be safe. If you like to use shared environments, you may want to have a --project flag that references that shared environment, and make sure that IJulia is installed in that environment. Also make sure that the environment is instantiated.","category":"page"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"You can edit the kernel.json file to fix any issues. Or, delete the entire folder containing the kernel.json file to start from scratch. This is entirely safe to do, or you could also use jupyter kernelspec uninstall <name> from the command line, see jupyter kernelspec --help. After deleting an old kernel, simply create a new one, using IJulia.installkernel from the Julia REPL.","category":"page"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"For further insight into kernel connection issues, look at the error messages emitted by Jupyter. If you started jupyter lab / jupyter notebook in the terminal, messages will be printed there, not in the web interface that you access via the browser. For more details, you can pass the --debug command line flag to jupyter. If you started Jupyter via IJulia.jupyterlab() / IJulia.notebook(), you must also pass verbose=true to see any of the output emitted by jupyter, including error messages about connection failures; cf. Debugging IJulia problems, below.","category":"page"},{"location":"manual/troubleshooting/#General-troubleshooting-tips","page":"Troubleshooting","title":"General troubleshooting tips","text":"","category":"section"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you ran into a problem with the above steps, after fixing the problem you can type Pkg.build() to try to rerun the install scripts.\nIf you tried it a while ago, try running Pkg.update() and try again: this will fetch the latest versions of the Julia packages in case the problem you saw was fixed.  Run Pkg.build(\"IJulia\") if your Julia version may have changed.  If this doesn't work, you could try just deleting the whole .julia/conda directory in your home directory (on Windows, it is called Users\\USERNAME\\.julia\\conda in your home directory) via rm(abspath(first(DEPOT_PATH), \"conda\"),recursive=true) in Julia and re-adding the packages.\nOn MacOS, you currently need MacOS 10.7 or later; MacOS 10.6 doesn't work (unless you compile Julia yourself, from source code).\nInternet Explorer 8 (the default in Windows 7) or 9 don't work with the notebook; use Firefox (6 or later) or Chrome (13 or later).  Internet Explorer 10 in Windows 8 works (albeit with a few rendering glitches), but Chrome or Firefox is better.\nIf the notebook opens up, but doesn't respond (the input label is In[*] indefinitely), try creating a new Python notebook (not Julia) from the New button in the Jupyter dashboard, to see if 1+1 works in Python.  If it is the same problem, then probably you have a firewall running on your machine (this is common on Windows) and you need to disable the firewall or at least to allow the IP address 127.0.0.1.  (For the Sophos endpoint security software, go to \"Configure Anti-Virus and HIPS\", select \"Authorization\" and then \"Websites\", and add 127.0.0.1 to \"Authorized websites\"; finally, restart your computer.) If the Python test works, then IJulia may not be installed in the global or default environment and you may need to install a custom Julia kernel that uses your required Project.toml (see Julia projects).\nTry running jupyter --version and make sure that it prints 3.0.0 or larger; earlier versions of IPython are no longer supported by IJulia.\nYou can try setting ENV[\"JUPYTER\"]=\"\"; Pkg.build(\"IJulia\") to force IJulia to go back to its own Conda-based Jupyter version (if you previously tried a different jupyter).","category":"page"},{"location":"manual/troubleshooting/#Debugging-IJulia-problems","page":"Troubleshooting","title":"Debugging IJulia problems","text":"","category":"section"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If IJulia is crashing (e.g. it gives you a \"kernel appears to have died\" message), you can modify it to print more descriptive error messages to the terminal by doing:","category":"page"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ENV[\"IJULIA_DEBUG\"]=true\nPkg.build(\"IJulia\")","category":"page"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Restart the notebook and look for the error message when IJulia dies. (This changes IJulia to default to verbose = true mode, and sets capture_stderr = false, hopefully sending a bunch of debugging to the terminal where you launched jupyter).","category":"page"},{"location":"manual/troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"When you are done, set ENV[\"IJULIA_DEBUG\"]=false and re-run Pkg.build(\"IJulia\") to turn off the debugging output.","category":"page"},{"location":"#IJulia","page":"Home","title":"IJulia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IJulia is a Julia-language backend combined with the Jupyter interactive environment (also used by IPython).  This combination allows you to interact with the Julia language using Jupyter/IPython's powerful graphical notebook, which combines code, formatted text, math, and multimedia in a single document.  It also works with JupyterLab, a Jupyter-based integrated development environment for notebooks and code. The nteract notebook desktop supports IJulia with detailed instructions for its installation with nteract.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(IJulia notebooks can also be re-used in other Julia code via the NBInclude package.)","category":"page"},{"location":"library/public/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"library/public/#General","page":"Public API","title":"General","text":"","category":"section"},{"location":"library/public/#IJulia.IJulia","page":"Public API","title":"IJulia.IJulia","text":"IJulia is a Julia-language backend combined with the Jupyter interactive environment (also used by IPython).  This combination allows you to interact with the Julia language using Jupyter/IPython's powerful graphical notebook, which combines code, formatted text, math, and multimedia in a single document.\n\nThe IJulia module is used in three ways\n\nTyping using IJulia; notebook() will launch the Jupyter notebook interface in your web browser.  This is an alternative to launching jupyter notebook directly from your operating-system command line.\nIn a running notebook, the IJulia module is loaded and IJulia.somefunctions can be used to interact with the running IJulia kernel:\nIJulia.load(filename) and IJulia.load_string(s) load the contents of a file or a string, respectively, into a notebook cell.\nIJulia.clear_output() to clear the output from the notebook cell, useful for simple animations.\nIJulia.clear_history() to clear the history variables In and Out.\npush_X_hook(f) and pop_X_hook(f), where X is either preexecute, postexecute, or posterror.  This allows you to insert a \"hook\" function into a list of functions to execute when notebook cells are evaluated.\nIJulia.set_verbose() enables verbose output about what IJulia is doing internally; this is mainly used for debugging.\nIt is used internally by the IJulia kernel when talking to the Jupyter server.\n\n\n\n\n\n","category":"module"},{"location":"library/public/#IJulia.inited","page":"Public API","title":"IJulia.inited","text":"inited is a global variable that is set to true if the IJulia kernel is running, i.e. in a running IJulia notebook.  To test whether you are in an IJulia notebook, therefore, you can check isdefined(Main, :IJulia) && IJulia.inited.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#IJulia.installkernel","page":"Public API","title":"IJulia.installkernel","text":"installkernel(name::AbstractString, options::AbstractString...;\n              julia::Cmd,\n              specname::AbstractString,\n              displayname::AbstractString,\n              env=Dict())\n\nInstall a new Julia kernel, where the given options are passed to the julia executable, the user-visible kernel name is given by name followed by the Julia version, and the env dictionary is added to the environment.\n\nThe new kernel name is returned by installkernel.  For example:\n\nkernelpath = installkernel(\"Julia O3\", \"-O3\", env=Dict(\"FOO\"=>\"yes\"))\n\ncreates a new Julia kernel in which julia is launched with the -O3 optimization flag and FOO=yes is included in the environment variables.\n\nThe displayname argument can be used to customize the name displayed in the Jupyter kernel list.\n\nThe returned kernelpath is the path of the installed kernel directory, something like /...somepath.../kernels/julia-o3-1.6 (in Julia 1.6).  The specname argument can be passed to alter the name of this directory (which defaults to name with spaces replaced by hyphens, and special characters other than - hyphen, . period and _ underscore replaced by _ underscores, and the Julia major and minor version appended).\n\nYou can uninstall the kernel by calling rm(kernelpath, recursive=true).\n\nYou can specify a custom command to execute Julia via keyword argument julia. For example, you may want specify that the Julia kernel is running in a Docker container (but Jupyter will run outside of it), by calling installkernel from within such a container instance like this (or similar):\n\ninstallkernel(\n    \"Julia via Docker\",\n    julia = `docker run --rm --net=host\n        --volume=/home/USERNAME/.local/share/jupyter:/home/USERNAME/.local/share/jupyter\n        some-container /opt/julia-1.x/bin/julia`\n)\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Launching-the-server","page":"Public API","title":"Launching the server","text":"","category":"section"},{"location":"library/public/#IJulia.jupyterlab","page":"Public API","title":"IJulia.jupyterlab","text":"jupyterlab(args=``; dir=homedir(), detached=false, port::Union{Nothing,Int}=nothing, verbose=false)\n\nSimilar to IJulia.notebook() but launches JupyterLab instead of the Jupyter notebook.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.notebook","page":"Public API","title":"IJulia.notebook","text":"notebook(args=``; dir=homedir(), detached=false, port::Union{Nothing,Int}=nothing, verbose=false)\n\nThe notebook() function launches the Jupyter notebook, and is equivalent to running jupyter notebook at the operating-system command-line.    The advantage of launching the notebook from Julia is that, depending on how Jupyter was installed, the user may not know where to find the jupyter executable.\n\nExtra arguments can be passed with the args argument, e.g. notebook(`--help`; verbose=true) to see the command help. By default, the notebook server is launched in the user's home directory, but this location can be changed by passing the desired path in the dir keyword argument. e.g. notebook(dir=pwd()) to use the current directory.\n\nBy default, notebook() does not return; you must hit ctrl-c or quit Julia to interrupt it, which halts Jupyter.  So, you must leave the Julia terminal open for as long as you want to run Jupyter.  Alternatively, if you run notebook(detached=true), the jupyter notebook will launch in the background, and will continue running even after you quit Julia.  (The only way to stop Jupyter will then be to kill it in your operating system's process manager.)\n\nWhen the optional keyword port is not nothing, open the notebook on the given port number.\n\nIf verbose=true then the stdout/stderr from Jupyter will be echoed to the terminal. Try enabling this if you're having problems connecting to a kernel to see if there's any useful error messages from Jupyter.\n\nFor launching a JupyterLab instance, see IJulia.jupyterlab().\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.qtconsole","page":"Public API","title":"IJulia.qtconsole","text":"qtconsole()\n\nLaunches qtconsole for the current kernel. IJulia must be initialized already.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#History","page":"Public API","title":"History","text":"","category":"section"},{"location":"library/public/#IJulia.In","page":"Public API","title":"IJulia.In","text":"In is a global dictionary of input strings, where In[n] returns the string for input cell n of the notebook (as it was when it was last evaluated).\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#IJulia.Out","page":"Public API","title":"IJulia.Out","text":"Out is a global dictionary of output values, where Out[n] returns the output from the last evaluation of cell n in the notebook.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#IJulia.ans","page":"Public API","title":"IJulia.ans","text":"ans is a global variable giving the value returned by the last notebook cell evaluated.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#IJulia.n","page":"Public API","title":"IJulia.n","text":"IJulia.n is the (integer) index of the last-evaluated notebook cell.\n\n\n\n\n\n","category":"constant"},{"location":"library/public/#IJulia.clear_history","page":"Public API","title":"IJulia.clear_history","text":"clear_history([indices])\n\nThe clear_history() function clears all of the input and output history stored in the running IJulia notebook.  This is sometimes useful because all cell outputs are remember in the Out global variable, which prevents them from being freed, so potentially this could waste a lot of memory in a notebook with many large outputs.\n\nThe optional indices argument is a collection of indices indicating a subset of cell inputs/outputs to clear.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.history","page":"Public API","title":"IJulia.history","text":"history([io], [indices...])\n\nThe history() function prints all of the input history stored in the running IJulia notebook in a format convenient for copying.\n\nThe optional indices argument is one or more indices or collections of indices indicating a subset input cells to print.\n\nThe optional io argument is for specifying an output stream. The default is stdout.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Cells","page":"Public API","title":"Cells","text":"","category":"section"},{"location":"library/public/#IJulia.clear_output","page":"Public API","title":"IJulia.clear_output","text":"clear_output(wait=false)\n\nCall clear_output() to clear visible output from the current notebook cell.  Using wait=true clears the output only when new output is available, which reduces flickering and is useful for simple animations.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.load","page":"Public API","title":"IJulia.load","text":"load(filename, replace=false)\n\nLoad the file given by filename into a new input code cell in the running IJulia notebook, analogous to the %load magics in IPython. If the optional argument replace is true, then the file contents replace the current cell rather than creating a new cell.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.load_string","page":"Public API","title":"IJulia.load_string","text":"load_string(s, replace=false)\n\nLoad the string s into a new input code cell in the running IJulia notebook, somewhat analogous to the %load magics in IPython. If the optional argument replace is true, then s replaces the current cell rather than creating a new cell.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#I/O","page":"Public API","title":"I/O","text":"","category":"section"},{"location":"library/public/#IJulia.readprompt","page":"Public API","title":"IJulia.readprompt","text":"readprompt(prompt::AbstractString; password::Bool=false)\n\nDisplay the prompt string, request user input, and return the string entered by the user.  If password is true, the user's input is not displayed during typing.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.set_max_stdio","page":"Public API","title":"IJulia.set_max_stdio","text":"set_max_stdio(max_output::Integer)\n\nSets the maximum number of bytes, max_output, that can be written to stdout and stderr before getting truncated. A large value here allows a lot of output to be displayed in the notebook, potentially bogging down the browser.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.reset_stdio_count","page":"Public API","title":"IJulia.reset_stdio_count","text":"reset_stdio_count()\n\nReset the count of the number of bytes written to stdout/stderr. See set_max_stdio for more details.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Cell-execution-hooks","page":"Public API","title":"Cell execution hooks","text":"","category":"section"},{"location":"library/public/#IJulia.push_preexecute_hook","page":"Public API","title":"IJulia.push_preexecute_hook","text":"push_preexecute_hook(f::Function)\n\nPush a function f() onto the end of a list of functions to execute before executing any notebook cell.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.pop_preexecute_hook","page":"Public API","title":"IJulia.pop_preexecute_hook","text":"pop_preexecute_hook(f::Function)\n\nRemove a function f() from the list of functions to execute before executing any notebook cell.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.push_postexecute_hook","page":"Public API","title":"IJulia.push_postexecute_hook","text":"push_postexecute_hook(f::Function)\n\nPush a function f() onto the end of a list of functions to execute after executing any notebook cell.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.pop_postexecute_hook","page":"Public API","title":"IJulia.pop_postexecute_hook","text":"pop_postexecute_hook(f::Function)\n\nRemove a function f() from the list of functions to execute after executing any notebook cell.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.push_posterror_hook","page":"Public API","title":"IJulia.push_posterror_hook","text":"pop_posterror_hook(f::Function)\n\nRemove a function f() from the list of functions to execute after an error occurs when a notebook cell is evaluated.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.pop_posterror_hook","page":"Public API","title":"IJulia.pop_posterror_hook","text":"pop_posterror_hook(f::Function)\n\nRemove a function f() from the list of functions to execute after an error occurs when a notebook cell is evaluated.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Python-initializers","page":"Public API","title":"Python initializers","text":"","category":"section"},{"location":"library/public/","page":"Public API","title":"Public API","text":"See the Python integration docs for more details.","category":"page"},{"location":"library/public/#IJulia.init_matplotlib","page":"Public API","title":"IJulia.init_matplotlib","text":"init_matplotlib()\n\nInitialize the integration with matplotlib.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.init_ipywidgets","page":"Public API","title":"IJulia.init_ipywidgets","text":"init_ipywidgets()\n\nInitialize the integration with ipywidgets by setting up the right hooks to allow ipywidgets to use IJulia comms.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#IJulia.init_ipython","page":"Public API","title":"IJulia.init_ipython","text":"init_ipython()\n\nInitialize the integration with IPython by overriding its display system to call Julia's display() instead.\n\n\n\n\n\n","category":"function"},{"location":"manual/usage/#Using-IJulia","page":"Using IJulia","title":"Using IJulia","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"There are various features of IJulia that allow you to interact with a running IJulia kernel.","category":"page"},{"location":"manual/usage/#General","page":"Using IJulia","title":"General","text":"","category":"section"},{"location":"manual/usage/#Detecting-that-code-is-running-under-IJulia","page":"Using IJulia","title":"Detecting that code is running under IJulia","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"If your code needs to detect whether it is running in an IJulia notebook (or other Jupyter client), it can check isdefined(Main, :IJulia) && Main.IJulia.inited.","category":"page"},{"location":"manual/usage/#Julia-projects","page":"Using IJulia","title":"Julia projects","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"The default Jupyter kernel that is installed by IJulia starts with the Julia command line flag --project=@.. A  Project.toml (or JuliaProject.toml) in the folder of a notebook (or in a parent folder of this notebook) will therefore automatically become the active project for that notebook. Users that don't want this behavior should install an additional IJulia kernel without that command line flag (see section Installing and customizing kernels).","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"If an existing Project.toml file is not found then, by default, an IJulia notebook will try to run a Julia kernel with its active project set from the global or default environment (usually of the form ~/.julia/environments/v1.x). If the IJulia package is not installed in that environment, then the Julia kernel selected by default will not be able to connect, and a Connection failed error will be displayed. In this case, users should install a additional Julia kernel that uses their chosen Julia environment. For example, if the desired environment is currently activated in the REPL then one possibility is to execute","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"IJulia.installkernel(\"Julia MyProjectEnv\", \"--project=$(Base.active_project())\")","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"and subsequently select the kernel starting with Julia MyProjectEnv from Kernel > Change Kernel in the menu of the Jupyter notebook.","category":"page"},{"location":"manual/usage/#Customizing-your-IJulia-environment","page":"Using IJulia","title":"Customizing your IJulia environment","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"If you want to run code every time you start IJulia–-but only when in IJulia–-add a startup_ijulia.jl file to your Julia config directory, e.g., ~/.julia/config/startup_ijulia.jl.","category":"page"},{"location":"manual/usage/#Julia-and-IPython-Magics","page":"Using IJulia","title":"Julia and IPython Magics","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"One difference from IPython is that the IJulia kernel does not use \"magics\", which are special commands prefixed with % or %% to execute code in a different language.   Instead, other syntaxes to accomplish the same goals are more natural in Julia, work in environments outside of IJulia code cells, and are often more powerful.","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"However, if you enter an IPython magic command in an IJulia code cell, it will print help explaining how to achieve a similar effect in Julia if possible. For example, the analogue of IPython's %load filename in IJulia is IJulia.load(\"filename\").","category":"page"},{"location":"manual/usage/#Input-and-output","page":"Using IJulia","title":"Input and output","text":"","category":"section"},{"location":"manual/usage/#Prompting-for-user-input","page":"Using IJulia","title":"Prompting for user input","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"When you are running in a notebook, ordinary I/O functions on stdin do not function.   However, you can prompt for the user to enter a string in one of two ways:","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"readline() and readline(stdin) both open a stdin> prompt widget where the user can enter a string, which is returned by readline.\nIJulia.readprompt(prompt) displays the prompt string prompt and returns a string entered by the user.  IJulia.readprompt(prompt, password=true) does the same thing but hides the text the user types.","category":"page"},{"location":"manual/usage/#Clearing-output","page":"Using IJulia","title":"Clearing output","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"Analogous to the IPython.display.clear_output() function in IPython, IJulia provides a function:","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"IJulia.clear_output(wait=false)","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"to clear the output from the current input cell.  If the optional wait argument is true, then the front-end waits to clear the output until a new output is available to replace it (to minimize flickering).  This is useful to make simple animations, via repeated calls to IJulia.clear_output(true) followed by calls to display(...) to display a new animation frame.","category":"page"},{"location":"manual/usage/#Input-and-output-history","page":"Using IJulia","title":"Input and output history","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"IJulia will store dictionaries of the user's input and output history for each session in exported variables called In and Out. To recall old inputs and outputs, simply index into them, e.g. In[1] or Out[5]. Sometimes, a user may find themselves outputting large matrices or other datastructures which will be stored in Out and hence not garbage collected, possibly hogging memory. If you find that IJulia is using too much memory after generating large outputs, empty this output dictionary:","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"empty!(Out)","category":"page"},{"location":"manual/usage/#Default-display-size","page":"Using IJulia","title":"Default display size","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"When Julia displays a large data structure such as a matrix, by default it truncates the display to a given number of lines and columns.  In IJulia, this truncation is to 30 lines and 80 columns by default.   You can change this default by the LINES and COLUMNS environment variables, respectively, which can also be changed within IJulia via ENV (e.g. ENV[\"LINES\"] = 60). (Like in the REPL, you can also display non-truncated data structures via print(x).)","category":"page"},{"location":"manual/usage/#Preventing-truncation-of-output","page":"Using IJulia","title":"Preventing truncation of output","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"The new default behavior of IJulia is to truncate stdout (via show or println) after 512kb. This to prevent browsers from getting bogged down when displaying the results. This limit can be increased to a custom value, like 1MB, as follows","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"IJulia.set_max_stdio(1 << 20)","category":"page"},{"location":"manual/usage/#Execution","page":"Using IJulia","title":"Execution","text":"","category":"section"},{"location":"manual/usage/#Setting-the-current-module","page":"Using IJulia","title":"Setting the current module","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"The module that code in an input cell is evaluated in can be set using Main.IJulia.set_current_module(::Module). It defaults to Main.","category":"page"},{"location":"manual/usage/#Opting-out-of-soft-scope","page":"Using IJulia","title":"Opting out of soft scope","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"By default, IJulia evaluates user code using \"soft\" global scope, via the SoftGlobalScope.jl package: this means that you don't need explicit global declarations to modify global variables in for loops and similar, which is convenient for interactive use.","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"To opt out of this behavior, making notebooks behave similarly to global code in Julia .jl files, you can set IJulia.SOFTSCOPE[] = false at runtime, or include the environment variable IJULIA_SOFTSCOPE=no environment of the IJulia kernel when it is launched.","category":"page"},{"location":"manual/usage/#Python-integration","page":"Using IJulia","title":"Python integration","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"IJulia has an extension for PythonCall.jl that can integrate with ipywidgets and matplotlib to allow using their interactive widgets. Usage in Julia should be almost exactly the same as in Python, with the caveat that some libraries may expect numpy.ndarray arguments and not know what to do with juliacall.ArrayValue arguments (see the mpl-interactions example). In this case you should convert the array to an ndarray by calling Py(x).to_numpy().","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"To enable the integrations you should call one of the Python initializer functions after loading PythonCall and before importing any other Python libraries. Otherwise some hooks may be set up too late.","category":"page"},{"location":"manual/usage/#Examples","page":"Using IJulia","title":"Examples","text":"","category":"section"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"Ipywidgets:","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"using PythonCall\nIJulia.init_ipywidgets()\nconst ipywidgets = pyimport(\"ipywidgets\")\n\nwidget = ipywidgets.IntSlider(5)\n\nwidget.value","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"(Image: )","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"Matplotlib:","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"using PythonCall\nIJulia.init_matplotlib()\nconst plt = pyimport(\"matplotlib.pyplot\")\n\nplt.figure()\nplt.imshow(rand(100, 100))\nplt.tight_layout()","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"(Image: )","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"And a more complex example with mpl-interactions:","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"using PythonCall\nIJulia.init_matplotlib()\n\nconst plt = pyimport(\"matplotlib.pyplot\")\nconst iplt = pyimport(\"mpl_interactions.ipyplot\")\n\nx = collect(range(0, pi, 100))\ntau = collect(range(0.5, 10, 100))\n\nf1(x; tau, beta) = @. sin(x * tau) * x * beta\nf2(x; tau, beta) = @. sin(x * beta) * x * tau\n\nfig, ax = plt.subplots(figsize=(7, 3.5))\n# Note the calls to Py(x).to_numpy() to convert `x` to an ndarray\ncontrols = iplt.plot(Py(x).to_numpy(), f1, tau=tau, beta=(1, 10, 100), label=\"f1\")\niplt.plot(Py(x).to_numpy(), f2, controls=controls, label=\"f2\")\nplt.legend()\nplt.grid()\nplt.tight_layout()","category":"page"},{"location":"manual/usage/","page":"Using IJulia","title":"Using IJulia","text":"(Image: )","category":"page"}]
}
